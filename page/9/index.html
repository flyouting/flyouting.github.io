<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>flyouting and shirley</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="flyouting and shirley">
<meta property="og:url" content="http://coofee.me/page/9/index.html">
<meta property="og:site_name" content="flyouting and shirley">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="flyouting and shirley">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="flyouting and shirley" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://ww2.sinaimg.cn/small/4a242739gw1eu09kkcr5xj2050050glt.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">flyouting and shirley</a></h1>
		</hgroup>

		
		<p class="header-subtitle">记录一点一滴</p>
		

		<!--
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		-->

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">首页</a></li>
				        
							<li><a href="/archives">文章列表</a></li>
				        
							<li><a href="/about">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/flyouting" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/flyouting" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/flyouting" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:flyouting@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				<div class="switch-part switch-part2"><script>var n ='b-26003349-pe-f-801';var ch ='pc_6'; var w1 = 200;var h1 = 280;</script> <script src='http://static.luna.58.com/js/mad.js'></script></div>
				
				<!--
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AndroidStudio/" style="font-size: 10px;">AndroidStudio</a> <a href="/tags/DB/" style="font-size: 12.5px;">DB</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/ImageSpan/" style="font-size: 10px;">ImageSpan</a> <a href="/tags/ORM/" style="font-size: 12.5px;">ORM</a> <a href="/tags/Python/" style="font-size: 12.5px;">Python</a> <a href="/tags/activeandroid/" style="font-size: 10px;">activeandroid</a> <a href="/tags/android/" style="font-size: 17.5px;">android</a> <a href="/tags/intent/" style="font-size: 10px;">intent</a> <a href="/tags/key/" style="font-size: 10px;">key</a> <a href="/tags/layout/" style="font-size: 10px;">layout</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/span/" style="font-size: 10px;">span</a> <a href="/tags/transitions/" style="font-size: 10px;">transitions</a> <a href="/tags/volley/" style="font-size: 15px;">volley</a> <a href="/tags/webview/" style="font-size: 10px;">webview</a> <a href="/tags/后台，多线程/" style="font-size: 10px;">后台，多线程</a> <a href="/tags/相机/" style="font-size: 15px;">相机</a> <a href="/tags/终端/" style="font-size: 10px;">终端</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
					</div>
				</section>
				-->
				
				<!--
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				-->
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">flyouting and shirley</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://ww2.sinaimg.cn/small/4a242739gw1eu09kkcr5xj2050050glt.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">flyouting and shirley</h1>
			</hgroup>
			
			<p class="header-subtitle">记录一点一滴</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">首页</a></li>
		        
					<li><a href="/archives">文章列表</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/flyouting" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/flyouting" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/flyouting" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:flyouting@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-android-volley5" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/16/android-volley5/" class="article-date">
  	<time datetime="2014-07-16T14:39:43.000Z" itemprop="datePublished">2014-07-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/16/android-volley5/">Volley框架的增强二</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###添加支持GZIP的网络请求<br>实现很简单，用GZIPInputStream封装一下数据流，看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class GZipRequest extends StringRequest &#123;</span><br><span class="line"></span><br><span class="line">	public GZipRequest(int method, String url, Response.Listener&lt;String&gt; listener, Response.ErrorListener errorListener) &#123;</span><br><span class="line">		super(method, url, listener, errorListener);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public GZipRequest(String url, Response.Listener&lt;String&gt; listener, Response.ErrorListener errorListener) &#123;</span><br><span class="line">		super(url, listener, errorListener);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// parse the gzip response using a GZIPInputStream</span><br><span class="line">	@Override</span><br><span class="line">	protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123;</span><br><span class="line">		String output = &quot;&quot;;</span><br><span class="line">		try &#123;</span><br><span class="line">			GZIPInputStream gStream = new GZIPInputStream(new ByteArrayInputStream(response.data));</span><br><span class="line">			InputStreamReader reader = new InputStreamReader(gStream);</span><br><span class="line">			BufferedReader in = new BufferedReader(reader);</span><br><span class="line">			String read;</span><br><span class="line">			while ((read = in.readLine()) != null) &#123;</span><br><span class="line">				output += read;</span><br><span class="line">			&#125;</span><br><span class="line">			reader.close();</span><br><span class="line">			in.close();</span><br><span class="line">			gStream.close();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			return Response.error(new ParseError());</span><br><span class="line">		&#125;</span><br><span class="line">		return Response.success(output, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###添加进度显示<br>首先需要定义一个接口，传递返回数据的进度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/** Callback interface for delivering the progress of the responses. */</span><br><span class="line">   public interface ProgressListener &#123;</span><br><span class="line">   	/**</span><br><span class="line">        * Callback method thats called on each byte transfer.</span><br><span class="line">        */</span><br><span class="line">   	void onProgress(long transferredBytes, long totalSize);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后需要在网络传输返回数据解析成字节数组的时候，添加上进度回调，网络执行主体代码在BasicNetwork文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/** Reads the contents of HttpEntity into a byte[]. */</span><br><span class="line">    private byte[] entityToBytes(Request&lt;?&gt; request, HttpEntity entity) throws IOException,</span><br><span class="line">            ServerError &#123;</span><br><span class="line">        PoolingByteArrayOutputStream bytes =</span><br><span class="line">                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());</span><br><span class="line">        byte[] buffer = null;</span><br><span class="line">        long totalSize = (int) entity.getContentLength();</span><br><span class="line">        try &#123;</span><br><span class="line">            ProgressListener progressListener = null;</span><br><span class="line">            if (request instanceof ProgressListener) &#123;</span><br><span class="line">                progressListener = (ProgressListener) request;</span><br><span class="line">            &#125;</span><br><span class="line">            InputStream in = entity.getContent();</span><br><span class="line">            if (in == null) &#123;</span><br><span class="line">                throw new ServerError();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer = mPool.getBuf(1024);</span><br><span class="line">            int count;</span><br><span class="line">            int transferredBytes = 0;</span><br><span class="line">            while ((count = in.read(buffer)) != -1) &#123;</span><br><span class="line">                bytes.write(buffer, 0, count);</span><br><span class="line">                transferredBytes += count;</span><br><span class="line">                if (null != progressListener) &#123;</span><br><span class="line">                    progressListener.onProgress(transferredBytes, totalSize);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return bytes.toByteArray();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // Close the InputStream and release the resources by</span><br><span class="line">                // &quot;consuming the content&quot;.</span><br><span class="line">                entity.consumeContent();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                // This can happen if there was an exception above that left the</span><br><span class="line">                // entity in</span><br><span class="line">                // an invalid state.</span><br><span class="line">                VolleyLog.v(&quot;Error occured when calling consumingContent&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            mPool.returnBuf(buffer);</span><br><span class="line">            bytes.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看到，我们是多传了一个Request的参数，把Request转化成了progressListener对象，这需要我们的Request实现ProgressListener接口，这里有个文件下载的Request，可以参考看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A canned request for retrieving the response body at a given URL as a String.</span><br><span class="line"> */</span><br><span class="line">public class DownloadRequest extends Request&lt;String&gt; implements ProgressListener &#123;</span><br><span class="line">    private final Listener&lt;String&gt; mListener;</span><br><span class="line">    private final String mDownloadPath;</span><br><span class="line">    private ProgressListener mProgressListener;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new request with the given method.</span><br><span class="line">     *</span><br><span class="line">     * @param method the request &#123;@link Method&#125; to use</span><br><span class="line">     * @param url URL to fetch the string at</span><br><span class="line">     * @param download_apth path to save the file to</span><br><span class="line">     * @param listener Listener to receive the String response</span><br><span class="line">     * @param errorListener Error listener, or null to ignore errors</span><br><span class="line">     */</span><br><span class="line">    public DownloadRequest(String url, String download_path, Listener&lt;String&gt; listener,</span><br><span class="line">            ErrorListener errorListener) &#123;</span><br><span class="line">        super(Method.GET, url, errorListener);</span><br><span class="line">        mDownloadPath =download_path;</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setOnProgressListener(ProgressListener listener)&#123;</span><br><span class="line">    	mProgressListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void deliverResponse(String response) &#123;</span><br><span class="line">    	if(null != mListener)&#123;</span><br><span class="line">    		mListener.onResponse(response);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123;</span><br><span class="line">        String parsed = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] data = response.data;</span><br><span class="line">		    //convert array of bytes into file</span><br><span class="line">		    FileOutputStream fileOuputStream = new FileOutputStream(mDownloadPath); </span><br><span class="line">		    fileOuputStream.write(data);</span><br><span class="line">		    fileOuputStream.close();</span><br><span class="line">		    parsed = mDownloadPath;</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            parsed = new String(response.data);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;  catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally&#123;</span><br><span class="line">			if(TextUtils.isEmpty(parsed))&#123;</span><br><span class="line">				parsed = &quot;&quot;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onProgress(long transferredBytes, long totalSize) &#123;</span><br><span class="line">		if(null != mProgressListener)&#123;</span><br><span class="line">			mProgressListener.onProgress(transferredBytes, totalSize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###关于HTTPS<br>volley默认是支持https的，但是因为默认调用中不包含SSLSocketFactory参数，所以默认都是http的，我们可以修改源码，默认调用中添加参数，或者用更简单的一个方法，允许所有证书。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class HTTPSTrustManager implements X509TrustManager &#123;</span><br><span class="line"></span><br><span class="line">    private static TrustManager[] trustManagers;</span><br><span class="line">    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void checkClientTrusted(</span><br><span class="line">            java.security.cert.X509Certificate[] x509Certificates, String s)</span><br><span class="line">            throws java.security.cert.CertificateException &#123;</span><br><span class="line">        // To change body of implemented methods use File | Settings | File</span><br><span class="line">        // Templates.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void checkServerTrusted(</span><br><span class="line">            java.security.cert.X509Certificate[] x509Certificates, String s)</span><br><span class="line">            throws java.security.cert.CertificateException &#123;</span><br><span class="line">        // To change body of implemented methods use File | Settings | File</span><br><span class="line">        // Templates.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isClientTrusted(X509Certificate[] chain) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isServerTrusted(X509Certificate[] chain) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        return _AcceptedIssuers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void allowAllSSL() &#123;</span><br><span class="line">        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean verify(String arg0, SSLSession arg1) &#123;</span><br><span class="line">                // TODO Auto-generated method stub</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        SSLContext context = null;</span><br><span class="line">        if (trustManagers == null) &#123;</span><br><span class="line">            trustManagers = new TrustManager[] &#123;</span><br><span class="line">                new HTTPSTrustManager()</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            context = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">            context.init(null, trustManagers, new SecureRandom());</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (KeyManagementException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpsURLConnection.setDefaultSSLSocketFactory(context</span><br><span class="line">                .getSocketFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改创建连接的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected HttpURLConnection createConnection(URL url) throws IOException &#123;</span><br><span class="line">        if (&quot;https&quot;.equals(url.getProtocol())) &#123;</span><br><span class="line">            HTTPSTrustManager.allowAllSSL();</span><br><span class="line">        &#125;</span><br><span class="line">        return (HttpURLConnection) url.openConnection();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，如果发现是https的请求，默认允许所有证书。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volley/">volley</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/笔记/">笔记</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-android-volley4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/16/android-volley4/" class="article-date">
  	<time datetime="2014-07-16T14:39:38.000Z" itemprop="datePublished">2014-07-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/16/android-volley4/">Volley框架的增强一</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Volley框架整体是很适合快速开发时使用的，但是在某些项目中，纠结于一些需求，Volley框架就需要自己动手改一改了。</p>
<p>##开放网络请求dispatcher线程数量</p>
<p>RequestQueue的构造函数中是可以定义网络请求线程池的数量的，但是在Volley中的newRequestQueue()方法中却没有线程数量的参数可以传入。这里可以添加一个。顺便可以在这里添加自定义L2缓冲区的参数。改动后代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 创建一个默认的请求队列实例，启动worker线程池 Creates a default instance of the worker pool</span><br><span class="line">     * and calls &#123;@link RequestQueue#start()&#125; on it.</span><br><span class="line">     * </span><br><span class="line">     * @param context A &#123;@link Context&#125; 用于创建 cache 文件夹.</span><br><span class="line">     * @param stack An &#123;@link HttpStack&#125; 用于网络, 默认为null.</span><br><span class="line">     * @param threadPoolSize 线程池数量</span><br><span class="line">     * @param cache L2级磁盘缓冲区</span><br><span class="line">     * @return A started &#123;@link RequestQueue&#125; instance.</span><br><span class="line">     */</span><br><span class="line">    public static RequestQueue newRequestQueue(Context context, HttpStack stack, Cache cache,</span><br><span class="line">            int threadPoolSize) &#123;</span><br><span class="line">        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line"></span><br><span class="line">        String userAgent = &quot;volley/0&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            String packageName = context.getPackageName();</span><br><span class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</span><br><span class="line">            userAgent = packageName + &quot;/&quot; + info.versionCode;</span><br><span class="line">        &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (stack == null) &#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</span><br><span class="line">                stack = new HurlStack();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Gingerbread之前的版本, 采用HttpUrlConnection 不太合适.</span><br><span class="line">                // 原因参考这里:</span><br><span class="line">                // http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span><br><span class="line">                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Network network = new BasicNetwork(stack);</span><br><span class="line">        RequestQueue queue;</span><br><span class="line">        if (threadPoolSize &lt;= 0) &#123;</span><br><span class="line">            queue = new RequestQueue(cache == null ? new DiskBasedCache(cacheDir) : cache, network);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            queue = new RequestQueue(cache == null ? new DiskBasedCache(cacheDir) : cache, network,</span><br><span class="line">                    threadPoolSize);</span><br><span class="line">        &#125;</span><br><span class="line">        queue.start();</span><br><span class="line"></span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>##修改网络超时时间</p>
<p>框架中默认的超时时间是2500毫秒，在中国这种环境中简直无法适应，所以稍微调整高点。10秒就还可以了，正常的网络这个值就行，如果不行也可以调整为30秒。修改文件为DefaultRetryPolicy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** 默认的超时时间 */</span><br><span class="line">    public static final int DEFAULT_TIMEOUT_MS = 10000;</span><br></pre></td></tr></table></figure></p>
<p>##定义一个优化后的ImageLoader</p>
<p>实际开发中一定会处理这样一个问题，ListView的每个Item都包含一个图片，在我们快速滑动ListView的时候，每个图片获取的逻辑操作都被启动了，但是由于Item的复用机制，在一个Item被复用的时候，这个item调起的图片请求线程可能还正在运行或者在排队，这时候我们需要把这个线程取消掉以节约资源。</p>
<p>Volley框架中有个NetworkImageView，在类里边包含了一个ImageContainer，当view被复用的时候，发现这个ImageContainer存在，我们就可以从这里获取之前的url，去队列里取消掉。但是这样的逻辑在默认的ImageLoader里是不存在的，我们需要自己添加一个。</p>
<p>主要逻辑代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public ImageContainer get(String requestUrl, ImageView imageView, Drawable placeHolder,</span><br><span class="line">            int maxWidth, int maxHeight) &#123;</span><br><span class="line"></span><br><span class="line">        // 当这个view被复用，查找是否有旧的图片加载请求绑定到这个ImageView</span><br><span class="line">        ImageContainer imageContainer = imageView.getTag() != null</span><br><span class="line">                &amp;&amp; imageView.getTag() instanceof ImageContainer ? (ImageContainer) imageView</span><br><span class="line">                .getTag() : null;</span><br><span class="line"></span><br><span class="line">        // 找到之前请求的图片地址</span><br><span class="line">        String recycledImageUrl = imageContainer != null ? imageContainer.getRequestUrl() : null;</span><br><span class="line"></span><br><span class="line">        // 如果新的图片地址为null，或者跟之前的请求地址不同</span><br><span class="line">        if (requestUrl == null || !requestUrl.equals(recycledImageUrl)) &#123;</span><br><span class="line">            if (imageContainer != null) &#123;</span><br><span class="line">                // 取消之前的请求</span><br><span class="line">                imageContainer.cancelRequest();</span><br><span class="line">                imageView.setTag(null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (requestUrl != null) &#123;</span><br><span class="line">                // 启动一个新的Request去请求新的地址</span><br><span class="line">                imageContainer = get(requestUrl,</span><br><span class="line">                        getImageListener(mResources, imageView, placeHolder, mFadeInImage),</span><br><span class="line">                        maxWidth, maxHeight);</span><br><span class="line">                // 把Request作为tag存入对应的ImageView</span><br><span class="line">                imageView.setTag(imageContainer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                imageView.setImageDrawable(placeHolder);</span><br><span class="line">                imageView.setTag(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return imageContainer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>###添加一个返回字节数据的ImageRequest</p>
<p>Volley中的ImageRequest有默认的数据解析，会转换成符合要求的bitmap返回，项目中有可能是gif类图片，如果转换成bitmap，会只有第一帧。这时我们需要拿到返回的数据，转换成我们需要的类型。而不是统统的都是bitmap。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过一个url获取图片数据，返回值为byte[]</span><br><span class="line"> * </span><br><span class="line"> * @author coffee</span><br><span class="line"> */</span><br><span class="line">public class OtherImageRequest extends Request&lt;byte[]&gt; &#123;</span><br><span class="line">    /** 请求超时时间 */</span><br><span class="line">    private static final int IMAGE_TIMEOUT_MS = 2000;</span><br><span class="line"></span><br><span class="line">    /** 重试次数 */</span><br><span class="line">    private static final int IMAGE_MAX_RETRIES = 2;</span><br><span class="line"></span><br><span class="line">    /** 超时时间的乘数，重试时才用到 */</span><br><span class="line">    private static final float IMAGE_BACKOFF_MULT = 2f;</span><br><span class="line"></span><br><span class="line">    private final Response.Listener&lt;byte[]&gt; mListener;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new image request</span><br><span class="line">     * </span><br><span class="line">     * @param url URL of the image</span><br><span class="line">     * @param listener Listener to receive</span><br><span class="line">     * @param errorListener Error listener, or null to ignore errors</span><br><span class="line">     */</span><br><span class="line">    public OtherImageRequest(String url, Response.Listener&lt;byte[]&gt; listener,</span><br><span class="line">            Response.ErrorListener errorListener) &#123;</span><br><span class="line">        super(Method.GET, url, errorListener);</span><br><span class="line">        setRetryPolicy(new DefaultRetryPolicy(IMAGE_TIMEOUT_MS, IMAGE_MAX_RETRIES,</span><br><span class="line">                IMAGE_BACKOFF_MULT));</span><br><span class="line">        mListener = listener;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Priority getPriority() &#123;</span><br><span class="line">        return Priority.LOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Response&lt;byte[]&gt; parseNetworkResponse(NetworkResponse response) &#123;</span><br><span class="line">        return Response.success(response.data, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void deliverResponse(byte[] response) &#123;</span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###给图片添加有效期<br>在图片获取中，一般服务端是没有<code>cache-control</code>的，所有图片在文件缓冲中的有效期往往是没有设置的，也就代表这没有这层缓冲。所以需要给图片缓冲加个有效期。在<code>HttpHeaderParser</code>文件中有<code>个parseCacheHeaders</code>方法是用来解析头文件，设置有效期的。所以，这里可以添加一个方法，专门针对<code>ImageRequest</code>来处理有效期。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Extracts a &#123;@link Cache.Entry&#125; from a &#123;@link NetworkResponse&#125;. This will</span><br><span class="line">    * ignore the http server&apos;s Cache-Control.</span><br><span class="line">    * </span><br><span class="line">    * @param response The network response to parse headers from</span><br><span class="line">    * @return a cache entry for the given response, or null if the response is</span><br><span class="line">    *         not cacheable.</span><br><span class="line">    */</span><br><span class="line">   public static Cache.Entry parseImageCacheHeaders(NetworkResponse response) &#123;</span><br><span class="line">       long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">       Map&lt;String, String&gt; headers = response.headers;</span><br><span class="line"></span><br><span class="line">       long serverDate = 0;</span><br><span class="line">       String serverEtag = null;</span><br><span class="line">       String headerValue;</span><br><span class="line"></span><br><span class="line">       headerValue = headers.get(&quot;Date&quot;);</span><br><span class="line">       if (headerValue != null) &#123;</span><br><span class="line">           serverDate = parseDateAsEpoch(headerValue);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       serverEtag = headers.get(&quot;ETag&quot;);</span><br><span class="line">       // in 30 minutes cache will be hit, but also refreshed on background</span><br><span class="line">       final long cacheHitButRefreshed = 30 * 60 * 1000;</span><br><span class="line">       // in 24 hours this cache entry expires completely</span><br><span class="line">       final long cacheExpired = 24 * 60 * 60 * 1000;</span><br><span class="line">       final long softExpire = now + cacheHitButRefreshed;</span><br><span class="line">       final long ttl = now + cacheExpired;</span><br><span class="line"></span><br><span class="line">       Cache.Entry entry = new Cache.Entry();</span><br><span class="line">       entry.data = response.data;</span><br><span class="line">       entry.etag = serverEtag;</span><br><span class="line">       entry.softTtl = softExpire;</span><br><span class="line">       entry.ttl = ttl;</span><br><span class="line">       entry.serverDate = serverDate;</span><br><span class="line">       entry.responseHeaders = headers;</span><br><span class="line"></span><br><span class="line">       return entry;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>设定30分钟后再次访问需要刷新，24小时文件完全过期，需要重新联网获取。<br>然后在ImageRequest中解析header的地方替换方法即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (bitmap == null) &#123;</span><br><span class="line">            return Response.error(new ParseError(response));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Response.success(bitmap, HttpHeaderParser.parseImageCacheHeaders(response));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>之后的工作有添加支持gzip的网络访问，添加自定义的L2缓冲区，添加网络请求进度。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volley/">volley</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/笔记/">笔记</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-android-volley3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/14/android-volley3/" class="article-date">
  	<time datetime="2014-07-14T14:39:26.000Z" itemprop="datePublished">2014-07-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/14/android-volley3/">Volley源码学习笔记三</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##图片获取</p>
<p>在<code>volley</code>中有个<code>ImageLoader</code>用于专门加载图片，看一下其中的重要对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** 处理ImageRequest的请求队列. */</span><br><span class="line">private final RequestQueue mRequestQueue;</span><br><span class="line"></span><br><span class="line">/** 第一级缓冲区，在进入volley前首先会这里查看有没有缓存 */</span><br><span class="line">private final ImageCache mCache;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一个keys -&gt; BatchedImageRequest的HashMap，</span><br><span class="line"> * 用来跟踪动态请求,这样我们可以合并多个请求相同的URL到一个网络请求。</span><br><span class="line"> */</span><br><span class="line">private final HashMap&lt;String, BatchedImageRequest&gt; mInFlightRequests =</span><br><span class="line">        new HashMap&lt;String, BatchedImageRequest&gt;();</span><br><span class="line"></span><br><span class="line">/** 一个保存当前需要等待响应HashMap */</span><br><span class="line">private final HashMap&lt;String, BatchedImageRequest&gt; mBatchedResponses =</span><br><span class="line">        new HashMap&lt;String, BatchedImageRequest&gt;();</span><br></pre></td></tr></table></figure></p>
<p><code>ImageLoader</code>的构造方法只需要传入一个请求队列对象，和一个缓冲区对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ImageLoader(RequestQueue queue, ImageCache imageCache) &#123;</span><br><span class="line">       mRequestQueue = queue;</span><br><span class="line">       mCache = imageCache;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个一级缓冲区对象我们可以自行扩展，只需要实现<code>ImageCache</code>接口即可。常用的就是<code>LRUCahce</code>。</p>
<p>在看<code>ImageLoader</code>中执行网络请求获得图片的代码前，需要先了解<code>ImageContainer</code>和<code>BatchedImageRequest</code>这两个类是什么概念，因为这关系到重复行url请求的合并。先看下<code>ImageContainer</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class ImageContainer &#123;</span><br><span class="line">     </span><br><span class="line">        private Bitmap mBitmap;</span><br><span class="line">        private final ImageListener mListener;</span><br><span class="line">        private final String mCacheKey;</span><br><span class="line">        private final String mRequestUrl;</span><br><span class="line">        </span><br><span class="line">        public ImageContainer(Bitmap bitmap, String requestUrl,</span><br><span class="line">                String cacheKey, ImageListener listener) &#123;</span><br><span class="line">            mBitmap = bitmap;</span><br><span class="line">            mRequestUrl = requestUrl;</span><br><span class="line">            mCacheKey = cacheKey;</span><br><span class="line">            mListener = listener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void cancelRequest() &#123;</span><br><span class="line">            if (mListener == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BatchedImageRequest request = mInFlightRequests.get(mCacheKey);</span><br><span class="line">            if (request != null) &#123;</span><br><span class="line">                boolean canceled = request.removeContainerAndCancelIfNecessary(this);</span><br><span class="line">                if (canceled) &#123;</span><br><span class="line">                    mInFlightRequests.remove(mCacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // check to see if it is already batched for delivery.</span><br><span class="line">                request = mBatchedResponses.get(mCacheKey);</span><br><span class="line">                if (request != null) &#123;</span><br><span class="line">                    request.removeContainerAndCancelIfNecessary(this);</span><br><span class="line">                    if (request.mContainers.size() == 0) &#123;</span><br><span class="line">                        mBatchedResponses.remove(mCacheKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类其实就是对图片请求相关数据进行了一次封装，包含了图片对象，图片缓存key，图片URL，图片的回调监听器。并包含了一个取消请求的方法。</p>
<p>再来看看<code>BatchedImageRequest</code>，这个其实是图片网络请求的一个封装，跟上个类不同的是，一个是对数据的封装，一个是对请求的封装，上边那个类对应的是一个具体位置的请求，这个类是对应的某一个URL的请求，比如app中有三个位置的<code>imageview</code>请求同一个url的图片，那就会有三个<code>ImageContainer</code>,而只有一个<code>BatchedImageRequest</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private class BatchedImageRequest &#123;</span><br><span class="line">       /** 被追踪的请求 */</span><br><span class="line">       private final Request&lt;?&gt; mRequest;</span><br><span class="line"></span><br><span class="line">       /** 请求返回的图片数据 */</span><br><span class="line">       private Bitmap mResponseBitmap;</span><br><span class="line"></span><br><span class="line">       /** 返回出现错误 */</span><br><span class="line">       private VolleyError mError;</span><br><span class="line"></span><br><span class="line">       /** 对于同一个url的request的有效的ImageContainers列表 */</span><br><span class="line">       private final LinkedList&lt;ImageContainer&gt; mContainers = new LinkedList&lt;ImageContainer&gt;();</span><br><span class="line">       </span><br><span class="line">      </span><br><span class="line">       public BatchedImageRequest(Request&lt;?&gt; request, ImageContainer container) &#123;</span><br><span class="line">           mRequest = request;</span><br><span class="line">           mContainers.add(container);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 如果出现其他同地址的请求，把ImageContainer添加进来</span><br><span class="line">        */</span><br><span class="line">       public void addContainer(ImageContainer container) &#123;</span><br><span class="line">           mContainers.add(container);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 某个ImageContainer被取消，即某个位置的图片请求取消，从当前列表中移除，如果是最后一个，代表这个请求不需要了，会取消整个请求</span><br><span class="line">        */</span><br><span class="line">       public boolean removeContainerAndCancelIfNecessary(ImageContainer container) &#123;</span><br><span class="line">           mContainers.remove(container);</span><br><span class="line">           if (mContainers.size() == 0) &#123;</span><br><span class="line">               mRequest.cancel();</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>简单说就是 <code>BatchedImageRequest</code>对象是请求某一个url的图片数据的执行者，如果好几个<code>ImageView</code>都需要加载同一个url的图片，那就会生成若干个<code>ImageContainer</code>加到<code>BatchedImageRequest</code>里来。代表这些都是同一请求。</p>
<p>现在可以看图片获取部分的代码了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public ImageContainer get(String requestUrl, ImageListener imageListener,</span><br><span class="line">           int maxWidth, int maxHeight) &#123;</span><br><span class="line">       // only fulfill requests that were initiated from the main thread.</span><br><span class="line">       throwIfNotOnMainThread();</span><br><span class="line"></span><br><span class="line">       final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight);</span><br><span class="line"></span><br><span class="line">       // Try to look up the request in the cache of remote images.</span><br><span class="line">       Bitmap cachedBitmap = mCache.getBitmap(cacheKey);</span><br><span class="line">       if (cachedBitmap != null) &#123;</span><br><span class="line">           // Return the cached bitmap.</span><br><span class="line">           ImageContainer container = new ImageContainer(cachedBitmap, requestUrl, null, null);</span><br><span class="line">           imageListener.onResponse(container, true);</span><br><span class="line">           return container;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // The bitmap did not exist in the cache, fetch it!</span><br><span class="line">       ImageContainer imageContainer =</span><br><span class="line">               new ImageContainer(null, requestUrl, cacheKey, imageListener);</span><br><span class="line"></span><br><span class="line">       // Update the caller to let them know that they should use the default bitmap.</span><br><span class="line">       imageListener.onResponse(imageContainer, true);</span><br><span class="line"></span><br><span class="line">       // Check to see if a request is already in-flight.</span><br><span class="line">       BatchedImageRequest request = mInFlightRequests.get(cacheKey);</span><br><span class="line">       if (request != null) &#123;</span><br><span class="line">           // If it is, add this request to the list of listeners.</span><br><span class="line">           request.addContainer(imageContainer);</span><br><span class="line">           return imageContainer;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // The request is not already in flight. Send the new request to the network and</span><br><span class="line">       // track it.</span><br><span class="line">       Request&lt;?&gt; newRequest =</span><br><span class="line">           new ImageRequest(requestUrl, new Listener&lt;Bitmap&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onResponse(Bitmap response) &#123;</span><br><span class="line">                   onGetImageSuccess(cacheKey, response);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, maxWidth, maxHeight,</span><br><span class="line">           Config.RGB_565, new ErrorListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">                   onGetImageError(cacheKey, error);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">       mRequestQueue.add(newRequest);</span><br><span class="line">       mInFlightRequests.put(cacheKey,</span><br><span class="line">               new BatchedImageRequest(newRequest, imageContainer));</span><br><span class="line">       return imageContainer;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>需要传入图片url，回调的监听器，目标图片的宽高，首先是获取<code>cachekey</code>，这个key是由图片url和宽高一起组成的。由这个key从一级缓冲区里查看有无缓存，如果有的话，封装一个默认的<code>ImageContainer</code>返回，没有的话，去正在运行的图片请求集合里去查，当前url是否正在被请求，如果是的话，把当前<code>ImageContainer</code>添加进入<code>Request</code>里的<code>ImageContainer</code>列表。否则的话，生成一个<code>ImageRequest</code>，添加进入队列执行网络请求，并在正在执行的网络集合中<code>mInFlightRequests</code>中添加此请求。</p>
<p>图片获取到之后是怎么操作的呢，在上代码中看到，会执行<code>onGetImageSuccess(cacheKey, response)</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void onGetImageSuccess(String cacheKey, Bitmap response) &#123;</span><br><span class="line">       // cache the image that was fetched.</span><br><span class="line">       mCache.putBitmap(cacheKey, response);</span><br><span class="line"></span><br><span class="line">       // remove the request from the list of in-flight requests.</span><br><span class="line">       BatchedImageRequest request = mInFlightRequests.remove(cacheKey);</span><br><span class="line"></span><br><span class="line">       if (request != null) &#123;</span><br><span class="line">           // Update the response bitmap.</span><br><span class="line">           request.mResponseBitmap = response;</span><br><span class="line"></span><br><span class="line">           // Send the batched response</span><br><span class="line">           batchResponse(cacheKey, request);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是把取得的<code>bitmap</code>放到一级缓冲区里，然后从正在执行的<code>Request</code>列表中移除，并把<code>Request</code>里的<code>mResponseBitmap</code>对象设置好，接着执行<code>batchResponse(cacheKey, request)</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void batchResponse(String cacheKey, BatchedImageRequest request) &#123;</span><br><span class="line">        mBatchedResponses.put(cacheKey, request);</span><br><span class="line">        // If we don&apos;t already have a batch delivery runnable in flight, make a new one.</span><br><span class="line">        // Note that this will be used to deliver responses to all callers in mBatchedResponses.</span><br><span class="line">        if (mRunnable == null) &#123;</span><br><span class="line">            mRunnable = new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (BatchedImageRequest bir : mBatchedResponses.values()) &#123;</span><br><span class="line">                        for (ImageContainer container : bir.mContainers) &#123;</span><br><span class="line">                            // If one of the callers in the batched request canceled the request</span><br><span class="line">                            // after the response was received but before it was delivered,</span><br><span class="line">                            // skip them.</span><br><span class="line">                            if (container.mListener == null) &#123;</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (bir.getError() == null) &#123;</span><br><span class="line">                                container.mBitmap = bir.mResponseBitmap;</span><br><span class="line">                                container.mListener.onResponse(container, false);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                container.mListener.onErrorResponse(bir.getError());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mBatchedResponses.clear();</span><br><span class="line">                    mRunnable = null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            // Post the runnable.</span><br><span class="line">            mHandler.postDelayed(mRunnable, mBatchResponseDelayMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是把<code>BatchedImageRequest</code>扔到了待处理的<code>BatchedImageRequest</code>的hashmap里，即<code>mBatchedResponses</code>，然后是遍历<code>mBatchedResponses</code>，依次获取其中的<code>BatchedImageRequest</code>对象，然后遍历这个对象中的<code>ImageContainer</code>集合，依次执行<code>ImageContainer</code>里的listener的回调方法。这样在默认的listener中就会设置图片到ImageView上了。</p>
<p>最后附上网上借用的流程图：</p>
<p><img src="http://bcs.duapp.com/myblog-wrodpress//blog/201404//imageload2.png" alt="此处输入图片的描述"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volley/">volley</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/笔记/">笔记</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-android-volley2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/13/android-volley2/" class="article-date">
  	<time datetime="2014-07-13T14:39:21.000Z" itemprop="datePublished">2014-07-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/13/android-volley2/">Volley源码学习笔记二</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##Request<br>这里看下网络请求类 <code>Request</code>。<br>先看下类图：<br><img src="https://raw.githubusercontent.com/flyouting/Blog_jepg/master/request.png" alt="此处输入图片的描述"></p>
<p>来看下Request类的重要属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Request&lt;T&gt; implements Comparable&lt;Request&lt;T&gt;&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    /** 请求方法  目前支持 GET, POST, PUT, and DELETE. */</span><br><span class="line">    private final int mMethod;</span><br><span class="line"></span><br><span class="line">    /** 请求的api地址 */</span><br><span class="line">    private final String mUrl;</span><br><span class="line"></span><br><span class="line">    /** 发生错误的回调接口 */</span><br><span class="line">    private final Response.ErrorListener mErrorListener;</span><br><span class="line">    </span><br><span class="line">    /** 请求的序号，相同优先级的请求在请求队列中根据序号来进行排序，序号低的排在队列前面。*/</span><br><span class="line">    private Integer mSequence;</span><br><span class="line"></span><br><span class="line">    /** 该请求所在的请求队列 */</span><br><span class="line">    private RequestQueue mRequestQueue;</span><br><span class="line"></span><br><span class="line">    /** 此请求的网络返回是否需要保存在缓存 */</span><br><span class="line">    private boolean mShouldCache = true;</span><br><span class="line"></span><br><span class="line">    /** 是否能被取消 */</span><br><span class="line">    private boolean mCanceled = false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是主要方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 返回请求体的字节数组表示。默认实现为返回null，所以如果是POST或PUT请求，子类需要重写这个方法。</span><br><span class="line">    *</span><br><span class="line">    * @throws AuthFailureError in the event of auth failure</span><br><span class="line">    */</span><br><span class="line">   public byte[] getBody() throws AuthFailureError &#123;</span><br><span class="line">       Map&lt;String, String&gt; params = getParams();</span><br><span class="line">       if (params != null &amp;&amp; params.size() &gt; 0) &#123;</span><br><span class="line">           return encodeParameters(params, getParamsEncoding());</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 抽象方法，需要子类实现，用以解析网路返回的原始数据</span><br><span class="line">     * 并返回一个特定的响应类型即Response&lt;T&gt;中的T类</span><br><span class="line">     * 传回null将会再deliverResponse时不进行分发处理</span><br><span class="line">     */</span><br><span class="line">    abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 用来将解析好的响应结果交付给监听器进行处理</span><br><span class="line">     * 传入的参数response需要保证为非空</span><br><span class="line">     * 解析失败的response将不会被分发处理</span><br><span class="line">     */</span><br><span class="line">    abstract protected void deliverResponse(T response);</span><br></pre></td></tr></table></figure>
<p><code>Request</code>实现<code>Comparable</code>接口来对<code>Request</code>的优先级进行比较，从而决定<code>Request</code>在队列中的顺序。优先级越高，在请求队列中排得越前，相同优先级的序号越低，排得越前。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compareTo(Request&lt;T&gt; other) &#123;</span><br><span class="line">    Priority left = this.getPriority();</span><br><span class="line">    Priority right = other.getPriority();</span><br><span class="line"></span><br><span class="line">    // High-priority requests are &quot;lesser&quot; so they are sorted to the front.</span><br><span class="line">    // Equal priorities are sorted by sequence number to provide FIFO ordering.</span><br><span class="line">    return left == right ?</span><br><span class="line">            this.mSequence - other.mSequence :</span><br><span class="line">            right.ordinal() - left.ordinal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Requestv派生出三个子类</code>JsonRequest<code>、</code>ImageRequest<code>、</code>ClearCacheRequest`。</p>
<p>##JsonRequest<br><code>JsonRequest&lt;T&gt;</code>也是一个抽象类，可以发送一个<code>Json</code>表示的请求体，并返回一个T类型的响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public JsonRequest(String url, String requestBody, Listener&lt;T&gt; listener,</span><br><span class="line">        ErrorListener errorListener) &#123;</span><br><span class="line">    this(Method.DEPRECATED_GET_OR_POST, url, requestBody, listener, errorListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认的方法是GET，除非<code>getPostBody()</code>和<code>getPostParams()</code>方法被重写，会默认<code>POST</code>方法。构造方法需要传入的参数API地址，请求体的<code>JSON</code>字符串<code>requestbody</code>，数据成功返回后的回调方法，网络错误的回调方法。</p>
<p><code>JsonArrayRequest</code>、<code>JsonObjectRequest</code>继承自<code>JsonRequest</code>，分别表示返回一个<code>JsonArray</code>响应的请求与返回一个<code>JsonObject</code>响应的请求。</p>
<p>##ImageRequest<br>根据一个URL来请求一个位图<code>Bitmap</code>，看构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ImageRequest(String url, Response.Listener&lt;Bitmap&gt; listener, int maxWidth, int maxHeight,</span><br><span class="line">           Config decodeConfig, Response.ErrorListener errorListener) &#123;</span><br><span class="line">       super(Method.GET, url, errorListener);</span><br><span class="line">       setRetryPolicy(</span><br><span class="line">               new DefaultRetryPolicy(IMAGE_TIMEOUT_MS, IMAGE_MAX_RETRIES, IMAGE_BACKOFF_MULT));</span><br><span class="line">       mListener = listener;</span><br><span class="line">       mDecodeConfig = decodeConfig;</span><br><span class="line">       mMaxWidth = maxWidth;</span><br><span class="line">       mMaxHeight = maxHeight;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mMaxWidth</code>： 解码位图的最大宽度，<code>mMaxHeight</code>：解码位图的最大高度，如果<code>mMaxWidth</code>，<code>mMaxHeight</code>都为0，则保持位图的原始尺寸，如果其中一个不为0，则按照原始位图的宽高比进行解码，如果都不为0，则将解码成最适合width * height区域并且保持原始位图宽高比的位图。另外还有个处理解码后的位图的监听器。</p>
<p><code>ImageRequest</code>的优先级是最低的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public Priority getPriority() &#123;</span><br><span class="line">       return Priority.LOW;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是，回调是返回的一个<code>bitmap</code>对象。网络数据返回时是byte数组，然后编码成<code>bitmap</code>，并有对宽高进行处理的逻辑，最后将符合要求的<code>bitmap</code>返回。对于普通的图片可以这样做，但是对于特别的格式，比如gif文件，不能返回bitmap，否则就会只返回第一帧，对于有这样需求的地方，需要自己定义一个新的图片获取<code>request</code>类，可以讲byte数组封装成自己需要的类型返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> private Response&lt;Bitmap&gt; doParse(NetworkResponse response) &#123;</span><br><span class="line">        byte[] data = response.data;</span><br><span class="line">        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();</span><br><span class="line">        Bitmap bitmap = null;</span><br><span class="line">        if (mMaxWidth == 0 &amp;&amp; mMaxHeight == 0) &#123;</span><br><span class="line">            decodeOptions.inPreferredConfig = mDecodeConfig;</span><br><span class="line">            bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If we have to resize this image, first get the natural bounds.</span><br><span class="line">            decodeOptions.inJustDecodeBounds = true;</span><br><span class="line">            BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);</span><br><span class="line">            int actualWidth = decodeOptions.outWidth;</span><br><span class="line">            int actualHeight = decodeOptions.outHeight;</span><br><span class="line"></span><br><span class="line">            // Then compute the dimensions we would ideally like to decode to.</span><br><span class="line">            int desiredWidth = getResizedDimension(mMaxWidth, mMaxHeight,</span><br><span class="line">                    actualWidth, actualHeight);</span><br><span class="line">            int desiredHeight = getResizedDimension(mMaxHeight, mMaxWidth,</span><br><span class="line">                    actualHeight, actualWidth);</span><br><span class="line"></span><br><span class="line">            // Decode to the nearest power of two scaling factor.</span><br><span class="line">            decodeOptions.inJustDecodeBounds = false;</span><br><span class="line">            // TODO(ficus): Do we need this or is it okay since API 8 doesn&apos;t support it?</span><br><span class="line">            // decodeOptions.inPreferQualityOverSpeed = PREFER_QUALITY_OVER_SPEED;</span><br><span class="line">            decodeOptions.inSampleSize =</span><br><span class="line">                findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);</span><br><span class="line">            Bitmap tempBitmap =</span><br><span class="line">                BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);</span><br><span class="line"></span><br><span class="line">            // If necessary, scale down to the maximal acceptable size.</span><br><span class="line">            if (tempBitmap != null &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth ||</span><br><span class="line">                    tempBitmap.getHeight() &gt; desiredHeight)) &#123;</span><br><span class="line">                bitmap = Bitmap.createScaledBitmap(tempBitmap,</span><br><span class="line">                        desiredWidth, desiredHeight, true);</span><br><span class="line">                tempBitmap.recycle();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bitmap = tempBitmap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bitmap == null) &#123;</span><br><span class="line">            return Response.error(new ParseError(response));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##ClearCacheRequest<br>一个模拟的用来清理缓存的请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ClearCacheRequest(Cache cache, Runnable callback) &#123;</span><br><span class="line">        super(Method.GET, null, null);</span><br><span class="line">        mCache = cache;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mCache</code>：需要清理的缓存，<code>mCallback</code>：缓存清理完后在主线程中被调用的回调接口。<code>parseNetworkResponse</code>与<code>deliverResponse</code>都是空实现，因为这是一个模拟的<code>Request</code>，没有实际的网络请求。</p>
<p><code>ClearCacheRequest</code>的优先级是最高的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public Priority getPriority() &#123;</span><br><span class="line">       return Priority.IMMEDIATE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在平时用的时候，我们可以写一些<code>request</code>的使用基类，因为有时候我们需要在每个请求里添加固定的几项参数，或者<code>header</code>。在基类里复写<code>getHeaders()</code>，<code>getParams()</code>方法。</p>
<p>##cache</p>
<p>这里看看<code>request</code>的访问缓存机制。</p>
<p><code>request</code>里用到的缓存对象是在<code>RequestQueue</code>的构造方法里传入的一个新创建的<code>DiskBasedCache</code>。</p>
<p>在<code>volley</code>中定义了一个<code>Cache</code>接口，并在此接口中定义了再<code>cache</code>中包存对象的数据结构<code>Entry</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public interface Cache &#123;</span><br><span class="line">   </span><br><span class="line">    public Entry get(String key);</span><br><span class="line">    public void put(String key, Entry entry);</span><br><span class="line">    public void initialize();</span><br><span class="line">    public void invalidate(String key, boolean fullExpire);</span><br><span class="line">    public void remove(String key);</span><br><span class="line">    public void clear();</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public static class Entry &#123;</span><br><span class="line">        /** The data returned from cache. */</span><br><span class="line">        public byte[] data;</span><br><span class="line">        /** Date of this response as reported by the server. */</span><br><span class="line">        public long serverDate;</span><br><span class="line">        /** TTL for this record. */</span><br><span class="line">        public long ttl;</span><br><span class="line">        /** Soft TTL for this record. */</span><br><span class="line">        public long softTtl;</span><br><span class="line">        /** Immutable response headers as received from server; must be non-null. */</span><br><span class="line">        public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line">        /** True if the entry is expired. */</span><br><span class="line">        public boolean isExpired() &#123;</span><br><span class="line">            return this.ttl &lt; System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        /** True if a refresh is needed from the original data source. */</span><br><span class="line">        public boolean refreshNeeded() &#123;</span><br><span class="line">            return this.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由代码可以看到接口中定义了常用的获取，添加，删除，清空方法。<code>Entry</code>的数据结构包含了字节数组对象，服务器时间，数据在本地生成的时间，软生成时间，这两个时间用于判断是否过期以及是否需要刷新数据。</p>
<p><code>DiskBasedCache</code>实现了Cache接口，重写了接口中的几个方法。先看一下添加进缓冲区对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public synchronized void put(String key, Entry entry) &#123;</span><br><span class="line">       pruneIfNeeded(entry.data.length);</span><br><span class="line">       File file = getFileForKey(key);</span><br><span class="line">       try &#123;</span><br><span class="line">           FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">           CacheHeader e = new CacheHeader(key, entry);</span><br><span class="line">           boolean success = e.writeHeader(fos);</span><br><span class="line">           if (!success) &#123;</span><br><span class="line">               fos.close();</span><br><span class="line">               VolleyLog.d(&quot;Failed to write header for %s&quot;, file.getAbsolutePath());</span><br><span class="line">               throw new IOException();</span><br><span class="line">           &#125;</span><br><span class="line">           fos.write(entry.data);</span><br><span class="line">           fos.close();</span><br><span class="line">           putEntry(key, e);</span><br><span class="line">           return;</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">       boolean deleted = file.delete();</span><br><span class="line">       if (!deleted) &#123;</span><br><span class="line">           VolleyLog.d(&quot;Could not clean up file %s&quot;, file.getAbsolutePath());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是检查对象的大小，当缓冲区空间足够新对象的加入时就直接添加进来，否则会删除部分对象，一直到新对象添加进来后还会有10%的空间剩余时为止。文件引用以<code>LinkHashMap</code>保存，默认的<code>LRU</code>策略。添加时，首先以URL为key，经过个文本转换后，以转换后的文本为名称，获取一个<code>file</code>对象。首先向这个对象写入缓存的头文件，然后是真正有用的网络返回数据。最后是当前内存占有量数值的更新，这里需要注意的是真实数据被写入磁盘文件后，在内存中维护的应用，存的只是数据的相关属性。</p>
<p>再看怎么从缓冲区获取数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public synchronized Entry get(String key) &#123;</span><br><span class="line">       CacheHeader entry = mEntries.get(key);</span><br><span class="line">       // if the entry does not exist, return.</span><br><span class="line">       if (entry == null) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       File file = getFileForKey(key);</span><br><span class="line">       CountingInputStream cis = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           cis = new CountingInputStream(new FileInputStream(file));</span><br><span class="line">           CacheHeader.readHeader(cis); // eat header</span><br><span class="line">           byte[] data = streamToBytes(cis, (int) (file.length() - cis.bytesRead));</span><br><span class="line">           return entry.toCacheEntry(data);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           VolleyLog.d(&quot;%s: %s&quot;, file.getAbsolutePath(), e.toString());</span><br><span class="line">           remove(key);</span><br><span class="line">           return null;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (cis != null) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   cis.close();</span><br><span class="line">               &#125; catch (IOException ioe) &#123;</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先根据key从缓存中获取<code>CacheHeader</code>，这里包含了真实数据的各种属性，然后再拿到存有数据的磁盘文件，先从文件中把头文件过滤，然后读取剩下的真正的数据部分到<code>CacheHeader</code>对象中，这样，一个完整的<code>CacheHeader</code>对象得到了，可以返回了。</p>
<p>由此可见，<code>Volley</code>中的第二层缓冲区即文件缓冲区对外不可见，是因为<code>RequestQueue</code>的构造方法直接生成了一个新的<code>DiskBasedCache</code>，如果开放出这个接口，可以传入自定义的<code>DiskCache</code>，只要实现<code>cache</code>接口，重写必要的方法就行，至于存储对象的数据结构，就看具体需求了。那些头文件中的数据属性信息其实也可以不存，直接把数据存成文件。比如在gif文件的支持中，我们需要在文件缓冲区中直接拿到gif的文件对象。这就需要在这一层次中添加接口了。</p>
<p>参考资料：<br><a href="http://www.cnblogs.com/spec-dog/p/3821417.html" target="_blank" rel="external">http://www.cnblogs.com/spec-dog/p/3821417.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volley/">volley</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/笔记/">笔记</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-android-volley1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/12/android-volley1/" class="article-date">
  	<time datetime="2014-07-12T14:37:54.000Z" itemprop="datePublished">2014-07-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/12/android-volley1/">Volley源码学习笔记一</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##Volley框架的官方架构图<br><img src="http://bcs.duapp.com/myblog-wrodpress//blog/201403//1.png" alt="此处输入图片的描述"></p>
<p>从图中大概可以看出，框架中包含三种线程，主线程，内存线程，网路线程。网络线程可以是多个，主线程负责将请求按优先权顺序添加进任务队列，内存线程查看缓存中是否有此请求，有的话从缓存中获取返回数据回馈给主线程，否则将请求交给网络线程，网络线程多个任务线程（<code>NetworkDispatcher</code>）组成，这些任务线程同时启动，不停的从任务队列中获取待执行的任务，执行完毕后把返回结果回馈给主线程。</p>
<p>##Volley框架HTTP请求流程图<br><img src="http://bcs.duapp.com/myblog-wrodpress//blog/201404//volley1.png" alt="此处输入图片的描述"></p>
<p>从图中可以简单了解到，各类请求添加进请求队列，然后分发给网络线程（<code>RequestDispatcher</code>），通过<code>HurlStack</code>或者<code>HttpClientStack</code>执行网络请求，得到<code>NetworkResponse</code>返回，如果是错误，可以retry一次，否则直接返回给主线程错误信息，如果返回数据正确，就会解析成<code>Response&lt;T&gt;</code> 通过<code>ResponseDelivery</code>返回给主线程。</p>
<p>##代码分析</p>
<p>首先是查看创建请求队列<code>RequestQueue</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it.</span><br><span class="line">    *</span><br><span class="line">    * @param context A &#123;@link Context&#125; to use for creating the cache dir.</span><br><span class="line">    * @param stack An &#123;@link HttpStack&#125; to use for the network, or null for default.</span><br><span class="line">    * @return A started &#123;@link RequestQueue&#125; instance.</span><br><span class="line">    */</span><br><span class="line">   public static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123;</span><br><span class="line">       //这里创建缓存目录</span><br><span class="line">       File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">       //这里创建默认的useragent</span><br><span class="line">       String userAgent = &quot;volley/0&quot;;</span><br><span class="line">       try &#123;</span><br><span class="line">           String packageName = context.getPackageName();</span><br><span class="line">           PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</span><br><span class="line">           userAgent = packageName + &quot;/&quot; + info.versionCode;</span><br><span class="line">       &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">       //可以传入一个自定义的HttpStack,比如OkHttpClient</span><br><span class="line">       if (stack == null) &#123;</span><br><span class="line">           if (Build.VERSION.SDK_INT &gt;= 9) &#123;</span><br><span class="line">               stack = new HurlStack();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // Prior to Gingerbread, HttpUrlConnection was unreliable.</span><br><span class="line">               // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span><br><span class="line">               stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Network network = new BasicNetwork(stack);</span><br><span class="line"></span><br><span class="line">       RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);</span><br><span class="line">       queue.start();</span><br><span class="line"></span><br><span class="line">       return queue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>先看下<code>HttpStack</code>，这里的一个参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * An HTTP stack abstraction.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Performs an HTTP request with the given parameters.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise,</span><br><span class="line">     * and the Content-Type header is set to request.getPostBodyContentType().&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> request the request to perform</span><br><span class="line">     * <span class="doctag">@param</span> additionalHeaders additional headers to be sent together with</span><br><span class="line">     *         &#123;<span class="doctag">@link</span> Request#getHeaders()&#125;</span><br><span class="line">     * <span class="doctag">@return</span> the HTTP response</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据描述可以看出这是一个抽象的Http请求客户端，为了兼容不同的网络请求。定义了一个网络执行方法，返回的是<code>HttpResponse</code>类型。即不管用何种方式执行网络请求，返回格式需要封装成HttpResponse。</p>
<p>代码中网络请求的实现由两种类型，一种是Java原生的<code>HttpURLConnection</code>实现（<code>HurlStack</code>），一种是Apache的<code>HttpClient</code>实现（<code>HttpClientStack</code>），Volley会在android2.3以前使用<code>HttpClient</code>实现，在android2.3及以后使用<code>HttpURLConnection</code>实现，至于原因，官方的解释是：在Eclair和Froyo上Apache HTTP client拥有更少的bug，更好的稳定性，在Gingerbread以及以后的版本中，<code>HttpURLConnection</code>是最好的选择，它简单的api以及轻量级非常适合Android。压缩和缓存机制降低了网路使用，提高了速度、节省了电量。</p>
<p>这里可以简单的看下<code>HurlStack</code>和<code>HttpClientStack</code>对于网络执行方法<code>performRequest</code>的重写代码：</p>
<p>HurlStack：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span><br><span class="line">           throws IOException, AuthFailureError &#123;</span><br><span class="line">       String url = request.getUrl();</span><br><span class="line">       HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">       map.putAll(request.getHeaders());</span><br><span class="line">       map.putAll(additionalHeaders);</span><br><span class="line">       if (mUrlRewriter != null) &#123;</span><br><span class="line">           String rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">           if (rewritten == null) &#123;</span><br><span class="line">               throw new IOException(&quot;URL blocked by rewriter: &quot; + url);</span><br><span class="line">           &#125;</span><br><span class="line">           url = rewritten;</span><br><span class="line">       &#125;</span><br><span class="line">       URL parsedUrl = new URL(url);</span><br><span class="line">       HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">       for (String headerName : map.keySet()) &#123;</span><br><span class="line">           connection.addRequestProperty(headerName, map.get(headerName));</span><br><span class="line">       &#125;</span><br><span class="line">       setConnectionParametersForRequest(connection, request);</span><br><span class="line">       // Initialize HttpResponse with data from the HttpURLConnection.</span><br><span class="line">       ProtocolVersion protocolVersion = new ProtocolVersion(&quot;HTTP&quot;, 1, 1);</span><br><span class="line">       int responseCode = connection.getResponseCode();</span><br><span class="line">       if (responseCode == -1) &#123;</span><br><span class="line">           // -1 is returned by getResponseCode() if the response code could not be retrieved.</span><br><span class="line">           // Signal to the caller that something was wrong with the connection.</span><br><span class="line">           throw new IOException(&quot;Could not retrieve response code from HttpUrlConnection.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       StatusLine responseStatus = new BasicStatusLine(protocolVersion,</span><br><span class="line">               connection.getResponseCode(), connection.getResponseMessage());</span><br><span class="line">       BasicHttpResponse response = new BasicHttpResponse(responseStatus);</span><br><span class="line">       response.setEntity(entityFromConnection(connection));</span><br><span class="line">       for (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</span><br><span class="line">           if (header.getKey() != null) &#123;</span><br><span class="line">               Header h = new BasicHeader(header.getKey(), header.getValue().get(0));</span><br><span class="line">               response.addHeader(h);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return response;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>HttpClientStack：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span><br><span class="line">           throws IOException, AuthFailureError &#123;</span><br><span class="line">       HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);</span><br><span class="line">       addHeaders(httpRequest, additionalHeaders);</span><br><span class="line">       addHeaders(httpRequest, request.getHeaders());</span><br><span class="line">       onPrepareRequest(httpRequest);</span><br><span class="line">       HttpParams httpParams = httpRequest.getParams();</span><br><span class="line">       int timeoutMs = request.getTimeoutMs();</span><br><span class="line">       // TODO: Reevaluate this connection timeout based on more wide-scale</span><br><span class="line">       // data collection and possibly different for wifi vs. 3G.</span><br><span class="line">       HttpConnectionParams.setConnectionTimeout(httpParams, 5000);</span><br><span class="line">       HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</span><br><span class="line">       return mClient.execute(httpRequest);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>两种不同的方式，但是返回都封装成了<code>HttpResponse</code>。</p>
<p>我们继续看执行网络请求的类Network和BasicNetwork<br>Network是一个接口，定义了一个执行网络请求的方法，BasicNetwork实现了这个接口，并根据不同的策略执行重连的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An interface for performing requests.</span><br><span class="line"> */</span><br><span class="line">public interface Network &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Performs the specified request.</span><br><span class="line">     * @param request Request to process</span><br><span class="line">     * @return A &#123;@link NetworkResponse&#125; with data and caching metadata; will never be null</span><br><span class="line">     * @throws VolleyError on errors</span><br><span class="line">     */</span><br><span class="line">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A network performing Volley requests over an &#123;@link HttpStack&#125;.</span><br><span class="line"> */</span><br><span class="line">public class BasicNetwork implements Network &#123;</span><br><span class="line">    protected static final boolean DEBUG = VolleyLog.DEBUG;</span><br><span class="line"></span><br><span class="line">    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;</span><br><span class="line"></span><br><span class="line">    private static int DEFAULT_POOL_SIZE = 4096;</span><br><span class="line">    </span><br><span class="line">    。。。</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</span><br><span class="line">        long requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            HttpResponse httpResponse = null;</span><br><span class="line">            byte[] responseContents = null;</span><br><span class="line">            Map&lt;String, String&gt; responseHeaders = new HashMap&lt;String, String&gt;();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 收集 headers.</span><br><span class="line">                Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();</span><br><span class="line">                addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">                //执行网络请求，获取返回数据</span><br><span class="line">                httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">                //获取状态码</span><br><span class="line">                StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">                int statusCode = statusLine.getStatusCode();</span><br><span class="line">                //获取headers</span><br><span class="line">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line">                // 处理缓存验证.</span><br><span class="line">                if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED,</span><br><span class="line">                            request.getCacheEntry() == null ? null : request.getCacheEntry().data,</span><br><span class="line">                            responseHeaders, true);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // 处理变动资源，如重定向</span><br><span class="line">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</span><br><span class="line">                	String newUrl = responseHeaders.get(&quot;Location&quot;);</span><br><span class="line">                	request.setRedirectUrl(newUrl);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 某些返回例如 204，不包含内容，需要检查  </span><br><span class="line">                if (httpResponse.getEntity() != null) &#123;</span><br><span class="line">                  responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                  // 对于无内容返回的请求，添加一个0字节的返回内容</span><br><span class="line">                  responseContents = new byte[0];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // if the request is slow, log it.</span><br><span class="line">                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line"></span><br><span class="line">                if (statusCode &lt; 200 || statusCode &gt; 299) &#123;</span><br><span class="line">                    throw new IOException();</span><br><span class="line">                &#125;</span><br><span class="line">                return new NetworkResponse(statusCode, responseContents, responseHeaders, false);</span><br><span class="line">            &#125; catch (SocketTimeoutException e) &#123;</span><br><span class="line">                attemptRetryOnException(&quot;socket&quot;, request, new TimeoutError());</span><br><span class="line">            &#125; catch (ConnectTimeoutException e) &#123;</span><br><span class="line">                attemptRetryOnException(&quot;connection&quot;, request, new TimeoutError());</span><br><span class="line">            &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;Bad URL &quot; + request.getUrl(), e);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                int statusCode = 0;</span><br><span class="line">                NetworkResponse networkResponse = null;</span><br><span class="line">                if (httpResponse != null) &#123;</span><br><span class="line">                    statusCode = httpResponse.getStatusLine().getStatusCode();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new NoConnectionError(e);</span><br><span class="line">                &#125;</span><br><span class="line">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </span><br><span class="line">                		statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</span><br><span class="line">                	VolleyLog.e(&quot;Request at %s has been redirected to %s&quot;, request.getOriginUrl(), request.getUrl());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                	VolleyLog.e(&quot;Unexpected response code %d for %s&quot;, statusCode, request.getUrl());</span><br><span class="line">                &#125;</span><br><span class="line">                if (responseContents != null) &#123;</span><br><span class="line">                    networkResponse = new NetworkResponse(statusCode, responseContents,</span><br><span class="line">                            responseHeaders, false);</span><br><span class="line">                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||</span><br><span class="line">                            statusCode == HttpStatus.SC_FORBIDDEN) &#123;</span><br><span class="line">                        attemptRetryOnException(&quot;auth&quot;,</span><br><span class="line">                                request, new AuthFailureError(networkResponse));</span><br><span class="line">                    &#125; else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </span><br><span class="line">                    			statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</span><br><span class="line">                        attemptRetryOnException(&quot;redirect&quot;,</span><br><span class="line">                                request, new AuthFailureError(networkResponse));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // TODO: Only throw ServerError for 5xx status codes.</span><br><span class="line">                        throw new ServerError(networkResponse);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new NetworkError(networkResponse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Network对象生成后，会生成<code>RequestQueue</code>对象，看下<code>RequestQueue</code>的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</span><br><span class="line">     *</span><br><span class="line">     * @param cache 一个存储responses到磁盘的缓存</span><br><span class="line">     * @param network 一个Network接口用以执行HTTP requests</span><br><span class="line">     * @param threadPoolSize network dispatcher线程数量</span><br><span class="line">     * @param delivery 一个ResponseDelivery接口用以分发 responses and errors</span><br><span class="line">     */</span><br><span class="line">    public RequestQueue(Cache cache, Network network, int threadPoolSize,</span><br><span class="line">            ResponseDelivery delivery) &#123;</span><br><span class="line">        mCache = cache;</span><br><span class="line">        mNetwork = network;</span><br><span class="line">        mDispatchers = new NetworkDispatcher[threadPoolSize];</span><br><span class="line">        mDelivery = delivery;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>默认的构造方法线程数是4，会生成一个默认的<code>ResponseDelivery</code>。然后<code>RequestQueue</code>会执行一个<code>start()</code>方法，启动一个<code>cache</code>线程和多个网络任务线程，等待执行任务。看源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Starts the dispatchers in this queue.</span><br><span class="line">    */</span><br><span class="line">   public void start() &#123;</span><br><span class="line">       stop();  // Make sure any currently running dispatchers are stopped.</span><br><span class="line">       // Create the cache dispatcher and start it.</span><br><span class="line">       mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">       mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">       // Create network dispatchers (and corresponding threads) up to the pool size.</span><br><span class="line">       for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">           NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                   mCache, mDelivery);</span><br><span class="line">           mDispatchers[i] = networkDispatcher;</span><br><span class="line">           networkDispatcher.start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>主体功能是创建一个内存分发器线程并启动，创建若干（默认是4）网络分发器线程并启动。分别来看下这两个类的代码，<code>CacheDispatcher</code>：<br>构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Creates a new cache triage dispatcher thread.  You must call &#123;@link #start()&#125;</span><br><span class="line">    * in order to begin processing.</span><br><span class="line">    *</span><br><span class="line">    * @param cacheQueue 对传入请求进行分流的队列 </span><br><span class="line">    * @param networkQueue 需要请求网络的requests 的队列</span><br><span class="line">    * @param cache Cache interface to use for resolution</span><br><span class="line">    * @param delivery Delivery 接口用以分发返回数据</span><br><span class="line">    */</span><br><span class="line">   public CacheDispatcher(</span><br><span class="line">           BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</span><br><span class="line">           Cache cache, ResponseDelivery delivery) &#123;</span><br><span class="line">       mCacheQueue = cacheQueue;</span><br><span class="line">       mNetworkQueue = networkQueue;</span><br><span class="line">       mCache = cache;</span><br><span class="line">       mDelivery = delivery;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>查看主要的run方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</span><br><span class="line">       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">       // Make a blocking call to initialize the cache.</span><br><span class="line">       mCache.initialize();</span><br><span class="line"></span><br><span class="line">       while (true) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               // 这里是从mCacheQueue队列获取请求</span><br><span class="line">               //注意这个队列的声明是BlockingQueue&lt;Request&lt;?&gt;&gt;</span><br><span class="line">               //如果没有元素会是阻塞状态</span><br><span class="line">               final Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">               request.addMarker(&quot;cache-queue-take&quot;);</span><br><span class="line"></span><br><span class="line">               // 检查请求是否已经被取消</span><br><span class="line">               if (request.isCanceled()) &#123;</span><br><span class="line">                   request.finish(&quot;cache-discard-canceled&quot;);</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // 尝试从缓存中去检索某一个请求</span><br><span class="line">               Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">               if (entry == null) &#123;</span><br><span class="line">                   request.addMarker(&quot;cache-miss&quot;);</span><br><span class="line">                   // 缓存中没有，传入网络线程队列</span><br><span class="line">                   mNetworkQueue.put(request);</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // 如果已经过期，传入网络线程队列</span><br><span class="line">               if (entry.isExpired()) &#123;</span><br><span class="line">                   request.addMarker(&quot;cache-hit-expired&quot;);</span><br><span class="line">                   request.setCacheEntry(entry);</span><br><span class="line">                   mNetworkQueue.put(request);</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // 缓存区有次请求数据; 解析数据，回传给请求</span><br><span class="line">               request.addMarker(&quot;cache-hit&quot;);</span><br><span class="line">               Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                       new NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">               request.addMarker(&quot;cache-hit-parsed&quot;);</span><br><span class="line"></span><br><span class="line">               if (!entry.refreshNeeded()) &#123;</span><br><span class="line">                   // 没有过期，只需要回传数据即可</span><br><span class="line">                   mDelivery.postResponse(request, response);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // Soft-expired cache hit. We can deliver the cached response,</span><br><span class="line">                   // but we need to also send the request to the network for</span><br><span class="line">                   // refreshing.</span><br><span class="line">                   request.addMarker(&quot;cache-hit-refresh-needed&quot;);</span><br><span class="line">                   request.setCacheEntry(entry);</span><br><span class="line"></span><br><span class="line">                   // Mark the response as intermediate.</span><br><span class="line">                   response.intermediate = true;</span><br><span class="line"></span><br><span class="line">                   // Post the intermediate response back to the user and have</span><br><span class="line">                   // the delivery then forward the request along to the network.</span><br><span class="line">                   mDelivery.postResponse(request, response, new Runnable() &#123;</span><br><span class="line">                       @Override</span><br><span class="line">                       public void run() &#123;</span><br><span class="line">                           try &#123;</span><br><span class="line">                               mNetworkQueue.put(request);</span><br><span class="line">                           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                               // Not much we can do about this.</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               // We may have been interrupted because it was time to quit.</span><br><span class="line">               if (mQuit) &#123;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>线程权重设置为<code>THREAD_PRIORITY_BACKGROUND</code>，然后是不断的从缓存队列中取对象，缓存队列采用了阻塞队列，当队列中没有元素中时处于阻塞状态，一直到有新元素添加进来。当取到对象，查验是否被取消，然后去缓存中查找,如果存在，检测是否过期，否则都会扔进网络线程。最后有个<code>refreshNeeded</code>方法，这个涉及是否服务端有过期策略的支持，下边再说。</p>
<p>看看比较重要的<code>NetworkDispatcher</code>：<br>还是先看构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Creates a new network dispatcher thread.  You must call &#123;@link #start()&#125;</span><br><span class="line">   * in order to begin processing.</span><br><span class="line">   *</span><br><span class="line">   * @param queue Queue of incoming requests for triage</span><br><span class="line">   * @param network Network interface to use for performing requests</span><br><span class="line">   * @param cache Cache interface to use for writing responses to cache</span><br><span class="line">   * @param delivery Delivery interface to use for posting responses</span><br><span class="line">   */</span><br><span class="line">  public NetworkDispatcher(BlockingQueue&lt;Request&gt; queue,</span><br><span class="line">          Network network, Cache cache,</span><br><span class="line">          ResponseDelivery delivery) &#123;</span><br><span class="line">      mQueue = queue;</span><br><span class="line">      mNetwork = network;</span><br><span class="line">      mCache = cache;</span><br><span class="line">      mDelivery = delivery;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>不同的是多了一个真正执行网络请求的network对象。</p>
<p>看看重要是<code>run</code>方法体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        Request request;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 从队列中获取一个请求</span><br><span class="line">                request = mQueue.take();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // We may have been interrupted because it was time to quit.</span><br><span class="line">                if (mQuit) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                request.addMarker(&quot;network-queue-take&quot;);</span><br><span class="line"></span><br><span class="line">                // 检测是否已经被取消</span><br><span class="line">                // 取消就不执行网络操作</span><br><span class="line">                if (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(&quot;network-discard-cancelled&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Tag the request (if API &gt;= 14)</span><br><span class="line">                if (Build.VERSION.SDK_INT &gt;= 14) &#123;</span><br><span class="line">                    TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 执行网络请求，得到返回数据networkresponse</span><br><span class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">                request.addMarker(&quot;network-http-complete&quot;);</span><br><span class="line"></span><br><span class="line">                // 如果服务端返回 304 我们已经分发过返回结果</span><br><span class="line">                // 就此结束，不需要再发一遍结果</span><br><span class="line">                if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                    request.finish(&quot;not-modified&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 在worker线程里解析返回的数据</span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">                request.addMarker(&quot;network-parse-complete&quot;);</span><br><span class="line"></span><br><span class="line">                // 如果需要，写入缓存中</span><br><span class="line">                // TODO: Only update cache metadata instead of entire record for 304s.</span><br><span class="line">                if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</span><br><span class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                    request.addMarker(&quot;network-cache-written&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 返回网络请求的结果</span><br><span class="line">                request.markDelivered();</span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; catch (VolleyError volleyError) &#123;</span><br><span class="line">                parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</span><br><span class="line">                mDelivery.postError(request, new VolleyError(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>网络请求的逻辑过程很清晰。这里我们再看看关于过期策略的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** True if the entry is expired. */</span><br><span class="line">     public boolean isExpired() &#123;</span><br><span class="line">         return this.ttl &lt; System.currentTimeMillis();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     /** True if a refresh is needed from the original data source. */</span><br><span class="line">     public boolean refreshNeeded() &#123;</span><br><span class="line">         return this.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>这是判断是否过期，是否需要刷新的地方，其实就是用一个记录的时候看看是否超过当前时间。那就需要查查这个ttl，softttl时间戳是在哪设置的。跟进代码找到设置的地方。在<code>HttpHeaderParser</code>类中的<code>parseCacheHeaders</code>方法里会对网络返回的数据进行解析，返回一个<code>Cache.Entry</code>对象。这里会设置时间戳。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">headerValue = headers.get(&quot;Cache-Control&quot;);</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">            hasCacheControl = true;</span><br><span class="line">            String[] tokens = headerValue.split(&quot;,&quot;);</span><br><span class="line">            for (int i = 0; i &lt; tokens.length; i++) &#123;</span><br><span class="line">                String token = tokens[i].trim();</span><br><span class="line">                if (token.equals(&quot;no-cache&quot;) || token.equals(&quot;no-store&quot;)) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125; else if (token.startsWith(&quot;max-age=&quot;)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        maxAge = Long.parseLong(token.substring(8));</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (token.equals(&quot;must-revalidate&quot;) || token.equals(&quot;proxy-revalidate&quot;)) &#123;</span><br><span class="line">                    maxAge = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> headerValue = headers.get(&quot;Expires&quot;);</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">            serverExpires = parseDateAsEpoch(headerValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverEtag = headers.get(&quot;ETag&quot;);</span><br><span class="line"></span><br><span class="line">        // Cache-Control takes precedence over an Expires header, even if both exist and Expires</span><br><span class="line">        // is more restrictive.</span><br><span class="line">        if (hasCacheControl) &#123;</span><br><span class="line">            softExpire = now + maxAge * 1000;</span><br><span class="line">        &#125; else if (serverDate &gt; 0 &amp;&amp; serverExpires &gt;= serverDate) &#123;</span><br><span class="line">            // Default semantic for Expire header in HTTP specification is softExpire.</span><br><span class="line">            softExpire = now + (serverExpires - serverDate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cache.Entry entry = new Cache.Entry();</span><br><span class="line">        entry.data = response.data;</span><br><span class="line">        entry.etag = serverEtag;</span><br><span class="line">        entry.softTtl = softExpire;</span><br><span class="line">        entry.ttl = entry.softTtl;</span><br><span class="line">        entry.serverDate = serverDate;</span><br><span class="line">        entry.responseHeaders = headers;</span><br></pre></td></tr></table></figure></p>
<p>从返回的<code>header</code>中取<code>serverExpires</code>，<code>Cache-Control</code>比<code>Expires header</code>具有更高的优先级，如果返回的header中包含<code>Cache-Control</code>，那就从header中获取maxAge，<code>softExpire</code>就是maxAge秒的有效期。否则就是从header中获取<code>serverExpires</code>和<code>serverDate</code>，两者相减就是有效期的数值。缓存中保存的对象有效期都被设置成了<code>softExpire</code>。</p>
<p>最后附上整体流程图：<br><img src="http://bcs.duapp.com/myblog-wrodpress//blog/201404//volley_cache.png" alt="此处输入图片的描述"></p>
<p>参考资料：<br><a href="http://tomkeyzhang.duapp.com/?p=7" target="_blank" rel="external">http://tomkeyzhang.duapp.com/?p=7</a><br>Volley源码：<br><a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volley/">volley</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/笔记/">笔记</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-androi-span-imagespan" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/07/androi-span-imagespan/" class="article-date">
  	<time datetime="2014-07-07T14:35:51.000Z" itemprop="datePublished">2014-07-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/07/androi-span-imagespan/">Span，一个强大的概念</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在这片文章中，我会表述利用Spans可以做什么，以及更高层次的使用。</p>
<p>你可以下载安装<a href="https://github.com/flavienlaurent/spans/raw/master/sample.apk" target="_blank" rel="external">示例apk</a>，或者下载<a href="https://github.com/flavienlaurent/spans" target="_blank" rel="external">源码</a></p>
<p>##框架层<br>主要规则：</p>
<ul>
<li>如果一个Span影响字符层次的文本格式化，它继承自<a href="http://developer.android.com/reference/android/text/style/CharacterStyle.html" target="_blank" rel="external">CharacterStyle</a></li>
<li>如果一个Span影响段落层次的文本格式化，它实现了<a href="http://developer.android.com/reference/android/text/style/ParagraphStyle.html" target="_blank" rel="external">ParagraphStyle</a></li>
<li>如果一个Span修改字符层次的文本外观，它实现了<a href="http://developer.android.com/reference/android/text/style/UpdateAppearance.html" target="_blank" rel="external">UpdateAppearance</a></li>
<li>如果一个Span修改字符层次的文本度量/大小，它实现了<a href="http://developer.android.com/reference/android/text/style/UpdateLayout.html" target="_blank" rel="external">UpdateLayout</a></li>
</ul>
<p>类图如下：<br><img src="http://flavienlaurent.com/blog/2014/01/31/spans/cdcharacterstyle.png" alt="此处输入图片的描述"></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/cdparagraphstyle.png" alt="此处输入图片的描述"></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/cdupdateappearance.png" alt="此处输入图片的描述"></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/cdupdatelayout.png" alt="此处输入图片的描述"></p>
<p>是不是有点复杂，推荐一款可视化的类的观察工具有助于直观的了解类结构 <a href="http://www.class-visualizer.net/ienlaurent/spans" target="_blank" rel="external">class visualizer</a> </p>
<p>##如何工作</p>
<p>###Layout</p>
<p>当你给一个TextView设置文本时，它使用基类–<a href="http://developer.android.com/reference/android/text/Layout.html" target="_blank" rel="external">Layout</a>来管理；文本的渲染。</p>
<p>这个Layout类包含一个boolean型的<code>mSpannedText</code>：当文本是一个Spanned(SpannableString implements Spanned)实例时是True，这个类只执行ParagraphStyle Spans。</p>
<p>draw方法调另外另个方法：</p>
<ul>
<li>drawBackground</li>
</ul>
<p>对于每一行文本，如果当前行没有一个<a href="http://developer.android.com/reference/android/text/style/LineBackgroundSpan.html" target="_blank" rel="external">LineBackgroundSpan</a>，<a href="http://flavienlaurent.com/blog/2014/01/31/spans/" target="_blank" rel="external">LineBackgroundSpan#drawBackground</a>会被调起。</p>
<ul>
<li>drawText</li>
</ul>
<p>对于每一行文本，在必要的时候它会计算<a href="http://developer.android.com/reference/android/text/style/LeadingMarginSpan.html" target="_blank" rel="external">LeadingMarginSpan</a> 和 <a href="http://developer.android.com/reference/android/text/style/LeadingMarginSpan.LeadingMarginSpan2.html" target="_blank" rel="external">LeadingMarginSpan2</a>，调用<a href="http://developer.android.com/reference/android/text/style/LeadingMarginSpan.html" target="_blank" rel="external">LeadingMarginSpan#drawLeadingMargin</a>，这也是<a href="http://developer.android.com/reference/android/text/style/AlignmentSpan.html" target="_blank" rel="external">AlignmentSpan</a>用于确定文本对齐的地方。最后,如果当前行完成spanned,类Layout会调用TextLine#draw。（每行都会创建个TextLine对象） </p>
<p>###TextLine</p>
<p>android.text.TextLine文档解释：代表一行文本样式,用于测量视觉秩序和渲染。</p>
<p>TextLine 类包含三个Spans的集合:</p>
<ul>
<li>MetricAffectingSpan集合</li>
<li>CharacterStyle集合</li>
<li>ReplacementSpan集合</li>
</ul>
<p>TextLine#handleRun方法很有意思，它是所有Spans用于渲染文本的地方，相对Spans的类型，它会调用：</p>
<ul>
<li>CharacterStyle#updateDrawState 改变TextPaint 对于MetricAffectingSpan和CharacterStyle Spans的设置。</li>
<li>TextLine#handleReplacement用于ReplacementSpan，它户调用Replacement#getSize 去获取replacement的宽，在需要时更新字体的度量，最后会调用Replacement#draw</li>
</ul>
<p>###FontMetrics<br>如果你想知道更多关于什么是字体度量,看看以下模式:<br><img src="http://flavienlaurent.com/blog/2014/01/31/spans/fontmetrics.png" alt="此处输入图片的描述"></p>
<p>##实际应用</p>
<p>###BulletSpan<br><a href="http://developer.android.com/reference/android/text/style/BulletSpan.html" target="_blank" rel="external">android.text.style.BulletSpan</a><br>BulletSpan影响段落级文本格式。它允许在段落开始处添加一个点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">public BulletSpan (int gapWidth, int color)</span><br><span class="line">-gapWidth: gap in px between bullet and text</span><br><span class="line">-color: bullet color (optionnal, default is transparent)</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//create a black BulletSpan with a gap of 15px</span></span><br><span class="line">span = <span class="keyword">new</span> BulletSpan(<span class="number">15</span>, Color.BLACK);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/bullet.png" alt="此处输入图片的描述"></p>
<p>###QuoteSpan<br><a href="http://developer.android.com/reference/android/text/style/QuoteSpan.html" target="_blank" rel="external">android.text.style.QuoteSpan</a></p>
<p>QuoteSpan影响段落级文本格式。它允许你在段落里添加一个竖线。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">public QuoteSpan (int color)</span><br><span class="line">-color: quote vertical line color (optionnal, default is Color.BLUE)</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//create a red quote</span></span><br><span class="line">span = <span class="keyword">new</span> QuoteSpan(Color.RED);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/quote.png" alt="此处输入图片的描述"></p>
<p>###AlignmentSpan.Standard<br><a href="http://developer.android.com/reference/android/text/style/AlignmentSpan.Standard.html" target="_blank" rel="external">android.text.style.AlignmentSpan.Standard</a></p>
<p>AlignmentSpan.Standard影响段落级文本格式。它允许一个段落居中，左对齐，右对齐等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">public Standard(Layout.Alignment align)</span><br><span class="line">-align: alignment to set</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//align center a paragraph</span></span><br><span class="line">span = <span class="keyword">new</span> AlignmentSpan.Standard(Layout.Alignment.ALIGN_CENTER);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/alignmentstandard.png" alt="此处输入图片的描述"></p>
<p>###UnderlineSpan<br><a href="http://developer.android.com/reference/android/text/style/UnderlineSpan.html" target="_blank" rel="external">android.text.style.UnderlineSpan</a></p>
<p>UnderlineSpan影响字符级文本格式。它可以是字符有下划线<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//underline a character</span></span><br><span class="line">span = <span class="keyword">new</span> UnderlineSpan();</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/underline.png" alt="此处输入图片的描述"></p>
<p>###StrikethroughSpan<br><a href="http://developer.android.com/reference/android/text/style/StrikethroughSpan.html" target="_blank" rel="external">android.text.style.StrikethroughSpan</a></p>
<p>StrikethroughSpan影响字符级文本格式。它可是是字符有删除线。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strikethrough a character</span></span><br><span class="line">span = <span class="keyword">new</span> StrikethroughSpan();</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/strikethrough.png" alt="此处输入图片的描述"></p>
<p>###SubscriptSpan<br><a href="http://developer.android.com/reference/android/text/style/SubscriptSpan.html" target="_blank" rel="external">android.text.style.SubscriptSpan</a><br>SubscriptSpan影响字符级文本格式。它可以是字符有下标字符<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//subscript a character</span></span><br><span class="line">span = <span class="keyword">new</span> SubscriptSpan();</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/subscript.png" alt="此处输入图片的描述"></p>
<p>###SuperscriptSpan<br><a href="http://developer.android.com/reference/android/text/style/SuperscriptSpan.html" target="_blank" rel="external">android.text.style.SuperscriptSpan</a><br>SuperscriptSpan影响字符级文本格式，它为字符变成上标<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//superscript a character</span></span><br><span class="line">span = <span class="keyword">new</span> SuperscriptSpan();</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/superscript.png" alt="此处输入图片的描述"></p>
<p>###BackgroundColorSpan<br><a href="http://developer.android.com/reference/android/text/style/BackgroundColorSpan.html" target="_blank" rel="external">android.text.style.BackgroundColorSpan</a></p>
<p>BackgroundColorSpan影响字符级文本格式。它允许为一个字符设置背景色。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">public BackgroundColorSpan (int color)</span><br><span class="line">-color: background color</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set a green background</span></span><br><span class="line">span = <span class="keyword">new</span> BackgroundColorSpan(Color.GREEN);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/bgcolor.png" alt="此处输入图片的描述"></p>
<p>###ForegroundColorSpan<br><a href="http://developer.android.com/reference/android/text/style/ForegroundColorSpan.html" target="_blank" rel="external">android.text.style.ForegroundColorSpan</a></p>
<p>ForegroundColorSpan影响字符级文本格式。它允许设置文本颜色。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">public ForegroundColorSpan (int color)</span><br><span class="line">-color: foreground color</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set a red foreground</span></span><br><span class="line">span = <span class="keyword">new</span> ForegroundColorSpan(Color.RED);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/fgcolor.png" alt="此处输入图片的描述"></p>
<p>###ImageSpan<br><a href="http://developer.android.com/reference/android/text/style/ImageSpan.html" target="_blank" rel="external">android.text.style.ImageSpan</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//replace a character by pic1_small image</span></span><br><span class="line">span = <span class="keyword">new</span> ImageSpan(<span class="keyword">this</span>, R.drawable.pic1_small);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/image.png" alt="此处输入图片的描述"></p>
<p>###StyleSpan<br><a href="http://developer.android.com/reference/android/text/style/AlignmentSpan.html" target="_blank" rel="external">android.text.style.StyleSpan</a><br>StyleSpan影响字符级文本格式。它允许为字符设置风格(粗体、斜体、正常)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">public StyleSpan (int style)</span><br><span class="line">-style: int describing the style (android.graphics.Typeface)</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set a bold+italic style</span></span><br><span class="line">span = <span class="keyword">new</span> StyleSpan(Typeface.BOLD | Typeface.ITALIC);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/style.png" alt="此处输入图片的描述"></p>
<p>###TypefaceSpan<br><a href="http://developer.android.com/reference/android/text/style/TypefaceSpan.html" target="_blank" rel="external">android.text.style.TypefaceSpan</a><br>TypefaceSpan影响字符级文本格式。它允许设置一个字体。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">public TypefaceSpan (String family)</span><br><span class="line">-family: a font family</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set the serif family</span></span><br><span class="line">span = <span class="keyword">new</span> TypefaceSpan(<span class="string">"serif"</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/typeface.png" alt="此处输入图片的描述"></p>
<p>###TextAppearanceSpan<br><a href="http://developer.android.com/reference/android/text/style/TextAppearanceSpan.html" target="_blank" rel="external">android.text.style.TextAppearanceSpan</a></p>
<p>TextAppearanceSpan影响字符级文本格式。它可以为文本设置样式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public  TextAppearanceSpan(Context context, int appearance, int colorList)</span><br><span class="line">-context: a valid context</span><br><span class="line">-appearance: text appearance resource (ex: android.R.style.TextAppearance_Small)</span><br><span class="line">-colorList: a text color resource (ex: android.R.styleable.Theme_textColorPrimary)</span><br><span class="line"></span><br><span class="line">public TextAppearanceSpan(String family, int style, int size, ColorStateList color, ColorStateList linkColor)</span><br><span class="line">-family: a font family</span><br><span class="line">-style: int describing the style (android.graphics.Typeface)</span><br><span class="line">-size: text size</span><br><span class="line">-color: a text color</span><br><span class="line">-linkColor: a link text color</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//set the serif family</span><br><span class="line">span = new TextAppearanceSpan(this/*a context*/, R.style.SpecialTextAppearance);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;SpecialTextAppearance&quot; parent=&quot;@android:style/TextAppearance&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:textColor&quot;&gt;@color/color1&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:textColorHighlight&quot;&gt;@color/color2&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:textColorHint&quot;&gt;@color/color3&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:textColorLink&quot;&gt;@color/color4&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:textSize&quot;&gt;28sp&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:textStyle&quot;&gt;italic&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/textappearance.png" alt="此处输入图片的描述"></p>
<p>###AbsoluteSizeSpan<br><a href="http://developer.android.com/reference/android/text/style/AbsoluteSizeSpan.html" target="_blank" rel="external">android.text.style.AbsoluteSizeSpan</a></p>
<p>AbsoluteSizeSpan影响字符级文本格式。它允许设置一个文本字符绝对大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public AbsoluteSizeSpan(int size, boolean dip)</span><br><span class="line">-size: a size</span><br><span class="line">-dip: false, size is in px; true, size is in dip (optionnal, default false)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//set text size to 24dp</span><br><span class="line">span = new AbsoluteSizeSpan(24, true);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/absolutesize.png" alt="此处输入图片的描述"></p>
<p>###RelativeSizeSpan<br><a href="http://developer.android.com/reference/android/text/style/RelativeSizeSpan.html" target="_blank" rel="external">android.text.style.RelativeSizeSpan</a></p>
<p>RelativeSizeSpan影响字符级文本格式。它允许设置一个文本字符相对大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public RelativeSizeSpan(float proportion)</span><br><span class="line">-proportion: a proportion of the actual text size</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//set text size 2 times bigger </span><br><span class="line">span = new RelativeSizeSpan(2.0f);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/relativesize.png" alt="此处输入图片的描述"></p>
<p>###ScaleXSpan<br><a href="http://developer.android.com/reference/android/text/style/ScaleXSpan.html" target="_blank" rel="external">android.text.style.ScaleXSpan</a></p>
<p>ScaleXSpan影响字符级文本格式。它允许扩大字符X轴上大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public ScaleXSpan(float proportion)</span><br><span class="line">-proportion: a proportion of actual text scale x</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//scale x 3 times bigger </span><br><span class="line">span = new ScaleXSpan(3.0f);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/scalex.png" alt="此处输入图片的描述"></p>
<p>###MaskFilterSpan<br>android.text.style.MaskFilterSpan</p>
<p>MaskFilterSpan影响字符级文本格式。它可以为字符设置一个<a href="http://developer.android.com/reference/android/graphics/MaskFilter.html" target="_blank" rel="external">android.graphics.MaskFilter</a>。<br>BlurMaskFilter不支持硬件加速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public MaskFilterSpan(MaskFilter filter)</span><br><span class="line">-filter: a filter to apply</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//Blur a character</span><br><span class="line">span = new MaskFilterSpan(new BlurMaskFilter(density*2, BlurMaskFilter.Blur.NORMAL));</span><br><span class="line">//Emboss a character</span><br><span class="line">span = new MaskFilterSpan(new EmbossMaskFilter(new float[] &#123; 1, 1, 1 &#125;, 0.4f, 6, 3.5f));</span><br></pre></td></tr></table></figure></p>
<p>BlurMaskFilter<img src="http://flavienlaurent.com/blog/2014/01/31/spans/maskfilterblur.png" alt="此处输入图片的描述"></p>
<p>EmbossMaskFilter 蓝色前景色加粗体<br><img src="http://flavienlaurent.com/blog/2014/01/31/spans/maskfilteremboss.png" alt="此处输入图片的描述"></p>
<p>##提高Span的应用层次<br>动态前景色<br><img src="http://flavienlaurent.com/blog/2014/01/31/spans/animateforegroundcolor.gif" alt="此处输入图片的描述"><br>ForegroundColorSpan是只读的。这意味着你不能改变实例化后的前景颜色。因此,要做的第一件事就是实现MutableForegroundColorSpan代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableForegroundColorSpan</span> <span class="keyword">extends</span> <span class="title">ForegroundColorSpan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mAlpha = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mForegroundColor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutableForegroundColorSpan</span><span class="params">(<span class="keyword">int</span> alpha, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">        mAlpha = alpha;</span><br><span class="line">        mForegroundColor = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutableForegroundColorSpan</span><span class="params">(Parcel src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(src);</span><br><span class="line">        mForegroundColor = src.readInt();</span><br><span class="line">        mAlpha = src.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.writeToParcel(dest, flags);</span><br><span class="line">        dest.writeInt(mForegroundColor);</span><br><span class="line">        dest.writeFloat(mAlpha);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint ds)</span> </span>&#123;</span><br><span class="line">        ds.setColor(getForegroundColor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@param</span> alpha from 0 to 255</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(<span class="keyword">int</span> alpha)</span> </span>&#123;</span><br><span class="line">        mAlpha = alpha;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setForegroundColor</span><span class="params">(<span class="keyword">int</span> foregroundColor)</span> </span>&#123;</span><br><span class="line">        mForegroundColor = foregroundColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getAlpha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mAlpha;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getForegroundColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Color.argb(mAlpha, Color.red(mForegroundColor), Color.green(mForegroundColor), Color.blue(mForegroundColor));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在你可以在同一实例中改透明值，前景色了，但是当你设置了这些属性，它不刷新视图:你必须手动重设SpannableString。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MutableForegroundColorSpan span = new MutableForegroundColorSpan(255, Color.BLACK);</span><br><span class="line">spannableString.setSpan(span, 0, text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">textView.setText(spannableString);</span><br><span class="line">//here the text is black and fully opaque</span><br><span class="line">span.setAlpha(100);</span><br><span class="line">span.setForegroundColor(Color.RED);</span><br><span class="line">//here the text hasn&apos;t changed.</span><br><span class="line">textView.setText(spannableString);</span><br><span class="line">//finally, the text is red and translucent</span><br></pre></td></tr></table></figure></p>
<p>现在我们想动画展示前景色，我们使用一个自定义的<a href="http://developer.android.com/reference/android/util/Property.html" target="_blank" rel="external">android.util.Property</a>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static final Property&lt;MutableForegroundColorSpan, Integer&gt; MUTABLE_FOREGROUND_COLOR_SPAN_FC_PROPERTY =</span><br><span class="line">new Property&lt;MutableForegroundColorSpan, Integer&gt;(Integer.class, &quot;MUTABLE_FOREGROUND_COLOR_SPAN_FC_PROPERTY&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void set(MutableForegroundColorSpan span, Integer value) &#123;</span><br><span class="line">        span.setForegroundColor(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer get(MutableForegroundColorSpan span) &#123;</span><br><span class="line">        return span.getForegroundColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>最后我们创建一个 ObjectAnimator，设置自定义的property，在onAnimationUpdate方法里刷新视图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MutableForegroundColorSpan span = new MutableForegroundColorSpan(255, Color.BLACK);</span><br><span class="line">mSpannableString.setSpan(span, 0, text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">ObjectAnimator objectAnimator = ObjectAnimator.ofInt(span, MUTABLE_FOREGROUND_COLOR_SPAN_FC_PROPERTY, Color.BLACK, Color.RED);</span><br><span class="line">objectAnimator.setEvaluator(new ArgbEvaluator());</span><br><span class="line">objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        //refresh</span><br><span class="line">        mText.setText(mSpannableString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">objectAnimator.start();</span><br></pre></td></tr></table></figure></p>
<p>###ActionBar烟花效果<br><img src="http://flavienlaurent.com/blog/2014/01/31/spans/animateabfireworks.gif" alt="此处输入图片的描述"></p>
<p>“烟花”动画是使字母随机淡入。首先,把文本切成多个Span(例如,一个字符一个Span),一个一个淡入。使用前面介绍MutableForegroundColorSpan,我们将创建一个特殊的对象代表一个Span集。并为每个调用setAlpha，并为每个span设置一个随机的透明值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FireworksSpanGroup</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> mAlpha;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;MutableForegroundColorSpan&gt; mSpans;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">FireworksSpanGroup</span><span class="params">(<span class="keyword">float</span> alpha)</span> </span>&#123;</span><br><span class="line">            mAlpha = alpha;</span><br><span class="line">            mSpans = <span class="keyword">new</span> ArrayList&lt;MutableForegroundColorSpan&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSpan</span><span class="params">(MutableForegroundColorSpan span)</span> </span>&#123;</span><br><span class="line">            span.setAlpha((<span class="keyword">int</span>) (mAlpha * <span class="number">255</span>));</span><br><span class="line">            mSpans.add(span);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Collections.shuffle(mSpans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(<span class="keyword">float</span> alpha)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> size = mSpans.size();</span><br><span class="line">            <span class="keyword">float</span> total = <span class="number">1.0f</span> * size * alpha;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span> ; index &lt; size; index++) &#123;</span><br><span class="line">                MutableForegroundColorSpan span = mSpans.get(index);</span><br><span class="line">                <span class="keyword">if</span>(total &gt;= <span class="number">1.0f</span>) &#123;</span><br><span class="line">                    span.setAlpha(<span class="number">255</span>);</span><br><span class="line">                    total -= <span class="number">1.0f</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    span.setAlpha((<span class="keyword">int</span>) (total * <span class="number">255</span>));</span><br><span class="line">                    total = <span class="number">0.0f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getAlpha</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mAlpha; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>创建自定义property<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Property&lt;FireworksSpanGroup, Float&gt; FIREWORKS_GROUP_PROGRESS_PROPERTY =</span><br><span class="line"><span class="keyword">new</span> Property&lt;FireworksSpanGroup, Float&gt;(Float.class, <span class="string">"FIREWORKS_GROUP_PROGRESS_PROPERTY"</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(FireworksSpanGroup spanGroup, Float value)</span> </span>&#123;</span><br><span class="line">        spanGroup.setProgress(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">get</span><span class="params">(FireworksSpanGroup spanGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spanGroup.getProgress();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>最后创建group，设置ObjectAnimator<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> FireworksSpanGroup spanGroup = <span class="keyword">new</span> FireworksSpanGroup();</span><br><span class="line"><span class="comment">//init the group with multiple spans</span></span><br><span class="line"><span class="comment">//spanGroup.addSpan(span);</span></span><br><span class="line"><span class="comment">//set spans on the ActionBar spannable title</span></span><br><span class="line"><span class="comment">//mActionBarTitleSpannableString.setSpan(span, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span></span><br><span class="line">spanGroup.init();</span><br><span class="line">ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(spanGroup, FIREWORKS_GROUP_PROGRESS_PROPERTY, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">objectAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//refresh the ActionBar title</span></span><br><span class="line">        setTitle(mActionBarTitleSpannableString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">objectAnimator.start();</span><br></pre></td></tr></table></figure></p>
<p>###Draw with your own Span</p>
<p>这里，我们会看到一种通过自定义Span的方式去绘制，这将为文本定制开启一个有趣的视角。</p>
<p>首先，我们需要创建一个自定义的Span，继承自抽象类<a href="http://developer.android.com/reference/android/text/style/ReplacementSpan.html" target="_blank" rel="external">ReplacementSpan</a>。</p>
<p>如果你只是想画一个自定义的背景，你可以实现<a href="http://developer.android.com/reference/android/text/style/LineBackgroundSpan.html" target="_blank" rel="external">LineBackgroundSpan</a>。<br>我们需要实现两个方法：</p>
<ul>
<li><a href="http://developer.android.com/reference/android/text/style/ReplacementSpan.html#getSize%28android.graphics.Paint,%20java.lang.CharSequence,%20int,%20int,%20android.graphics.Paint.FontMetricsInt%29" target="_blank" rel="external">getSize</a> 这个方法返回替代位的宽度<br>text: Span管理的文本<br>start: 文本的开始位置<br>end: 文本的结束位置<br>fm: 字体度量, 可以为null</li>
<li><a href="http://developer.android.com/reference/android/text/style/ReplacementSpan.html#draw%28android.graphics.Canvas,%20java.lang.CharSequence,%20int,%20int,%20float,%20int,%20int,%20int,%20android.graphics.Paint%29" target="_blank" rel="external">draw</a>这里你可以通过canvas绘制<br>x: 绘制文本的X坐标<br>top: 行顶<br>y: 蓟县<br>bottom: 行底</li>
</ul>
<p>我们来看一个例子，在文字周围绘制一个蓝色矩形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) &#123;</span><br><span class="line">    //return text with relative to the Paint</span><br><span class="line">    mWidth = (int) paint.measureText(text, start, end);</span><br><span class="line">    return mWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123;</span><br><span class="line">    //draw the frame with custom Paint</span><br><span class="line">    canvas.drawRect(x, top, x + mWidth, bottom, mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://flavienlaurent.com/blog/2014/01/31/spans/framespan.png" alt="此处输入图片的描述"></p>
<p>###其他例子</p>
<ul>
<li>逐渐模糊<br><img src="http://flavienlaurent.com/blog/2014/01/31/spans/animateblur.gif" alt="此处输入图片的描述"></li>
<li>打字机<br><img src="http://flavienlaurent.com/blog/2014/01/31/spans/animatetypewriter.gif" alt="此处输入图片的描述"></li>
</ul>
<p>##总结</p>
<p>写文章的过程中，我意识到Spans真的很强大，像drawables，我想他们还没有被使用的足够多，文本是一个应用中的主要内容，它无处不在，所以不要忘记用Span使它更具活力和新引力。</p>
<p><a href="http://flavienlaurent.com/blog/2014/01/31/spans/" target="_blank" rel="external">原文地址</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ImageSpan/">ImageSpan</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/span/">span</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/译文/">译文</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-best-practices-for-background-jobs" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/05/best-practices-for-background-jobs/" class="article-date">
  	<time datetime="2014-07-05T14:33:48.000Z" itemprop="datePublished">2014-07-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/05/best-practices-for-background-jobs/">Android后台任务最佳实践</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://developer.android.com/training/best-background.html" target="_blank" rel="external">官方文档地址</a></p>
<p>##在后台服务中运行</p>
<p>除非你做特别指定，否则在应用中的大部分操作都是执行在前台，在一个特殊的UI线程里面进行的。这有可能会导致一些问题，因为长时间运行的操作会影响到你应用的响应速度。为了避免这个问题，android框架提供了一系列帮助你在后台通过线程推迟加载的功能，用得最多的就是<a href="http://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="external"><code>IntentService</code></a>。</p>
<p>这里将向你描述如何实现一个<code>IntentService</code>，发送请求操作并向其它组件报告结果。</p>
<p>###创建一个后台服务<br><code>IntentService</code>类为一个操作运行在一个线程上提供了一个简单的结构，这允许它可以处理长时间运行的操作而不影响你的用户界面的响应。同时，一个<code>IntentService</code>不被大多数用户界面的生命周期事件影响，因此它可以在异步任务关闭时继续运行。</p>
<p>每个<code>IntentService</code>都是有限制条件的：</p>
<ol>
<li>它不可以直接和应用的界面进行交互，为了将操作结果返回给界面，你需要将他们发送到<code>Activity</code>。</li>
<li>工作请求是按顺序进行的，当已经有一个操作在<code>IntentService</code>中运行时，如果这时你发送另外一个请求，需要等到第一个操作执行完毕后才会继续后面的请求</li>
<li>在<code>IntentService</code>中运行的操作是不可以被中断的</li>
</ol>
<p>然而，多数情况下一个<code>IntentService</code>是后台操作最适合的处理方式。</p>
<p>这里将告诉你如何创建你自己的<code>IntentService</code>子类，还会向你展示如何创建一个必要的<code>onHandleIntent()</code>回调。最后，将告诉你如何在manifest文件中定义<code>IntentService</code>。</p>
<p>####创建一个IntentService<br>为了在你的应用中创建一个<code>IntentService</code>组件，需要定义一个继承于<code>IntentService</code>的类并复写其<code>onHandleIntent()</code>方法，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSSPullService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent workIntent)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// Gets data from the incoming Intent  </span></span><br><span class="line">        String dataString = workIntent.getDataString();  </span><br><span class="line">        ...  </span><br><span class="line">        <span class="comment">// Do work here, based on the contents of dataString  </span></span><br><span class="line">        ...  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，对于任何一个<code>Service</code>都会回调的那些方法，比如<code>onStartCommand()</code>，都会自动地被<code>IntentService</code>引用。在一个<code>IntentService</code>中，你应该避免复写这些回调方法。</p>
<p>####在件Manifest中定义IntentService</p>
<p><code>IntentService</code>同样需要在你应用的清单文件中有一个入口，通过在<code>&lt;application&gt;</code>标签下声明<code>&lt;service&gt;</code>的方式来为<code>IntentService</code>提供入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:icon=<span class="string">"@drawable/icon"</span></span><br><span class="line">    android:label=<span class="string">"@string/app_name"</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;!--</span><br><span class="line">        Because android:exported is set to <span class="string">"false"</span>,</span><br><span class="line">        the service is only available to <span class="keyword">this</span> app.</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;service</span><br><span class="line">        android:name=<span class="string">".RSSPullService"</span></span><br><span class="line">        android:exported=<span class="string">"false"</span>/&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;application/&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>“android:name”</code>属性指定了<code>IntentService</code>的类名。</p>
<p>注意，<code>&lt;service&gt;</code>标签没有包含<code>IntentFilter</code>过滤器。该窗口通过一个明确地Intent向服务发送工作请求，所以不需要任何过滤器。也就是说，只有在同一个应用内，或者是有相同ID的其它应用才可以访问这个服务。</p>
<p>现在你有了基本的<code>IntentService</code>类，你可以通过Intent对象发送工作请求了。</p>
<p>###向后台服务发送工作请求</p>
<p>这里将告诉你如何通过发送Intent来触发<code>IntentService</code>执行一个操作。这个Intent可以包含<code>IntentService</code>需要处理的可选数据。你可以在<code>Activity</code>或者<code>Fragment</code>的任何一个地方向<code>IntentService</code>传递Intent。</p>
<p>####创建并发送一个工作请求给IntentService</p>
<p>为了创建一个工作请求并将其发送到<code>IntentService</code>，需要创建一个明确地Intent来添加工作请求数据，然后通过调用<code>IntentService</code>的<code>StartService()</code>方法来发送它。</p>
<p>具体实例如下：</p>
<p> 1.为<code>IntentService</code>的子类<code>RSSPullService</code>创建一个新的、明确地Intent。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Creates a new Intent to start the RSSPullService</span><br><span class="line"> * IntentService. Passes a URI in the</span><br><span class="line"> * Intent's "data" field.</span><br><span class="line"> */</span></span><br><span class="line">mServiceIntent = <span class="keyword">new</span> Intent(getActivity(), RSSPullService.class);</span><br><span class="line">mServiceIntent.setData(Uri.parse(dataUrl));</span><br></pre></td></tr></table></figure></p>
<p> 2.调用<code>startService()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Starts the IntentService</span></span><br><span class="line">getActivity().startService(mServiceIntent);</span><br></pre></td></tr></table></figure></p>
<p>注意，你可以在<code>Activity</code>或者<code>Fragment</code>的任何地方发送工作请求。比如，如果你需要首先获取用户输入，你可以在按钮点击或者类似于手势操作的回调中来发送请求。</p>
<p>一旦你调用了<code>startService()</code>方法，<code>IntentService</code>会处理定义在<code>onHandleIntent()</code>方法中的工作，然后自己停止。</p>
<p>下一步是向原始的<code>Activity</code>或者<code>Fragment</code>报告工作请求的结果。</p>
<p>###报告工作状态<br>这里将告诉你如何将后台服务的请求工作状态报告给发送请求的组件。这将允许你，比如报告一个窗口对象的UI更新请求状态。一般推荐使用<code>LocalBroadcastManager</code>来发送和接收这些状态，但这仅限于在你自己应用的各组件中广播Intent。</p>
<p>####从<code>IntentService</code>中报告状态</p>
<p>为了在<code>IntentService</code>中向其他组件发送工作请求状态，首先你需要创建一个包含状态信息数据的Intent，作为了一个选项，你可以在Intent中添加一个操作或者数据URI。</p>
<p>下一步，通过调用<code>LocalBroadcastManager.sendBroadcast()</code>方法来发送Intent，在你应用中发送到其它组件的Intent是注册过的。通过<code>LocalBroadcastManager</code>的<code>getInstance()</code>方法来实例化<code>LocalBroadcastManager</code>。</p>
<p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Defines a custom Intent action</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROADCAST_ACTION =</span><br><span class="line">        <span class="string">"com.example.android.threadsample.BROADCAST"</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Defines the key for the status "extra" in an Intent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTENDED_DATA_STATUS =</span><br><span class="line">        <span class="string">"com.example.android.threadsample.STATUS"</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSSPullService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Creates a new Intent containing a Uri object</span><br><span class="line">     * BROADCAST_ACTION is a custom Intent action</span><br><span class="line">     */</span></span><br><span class="line">    Intent localIntent =</span><br><span class="line">            <span class="keyword">new</span> Intent(Constants.BROADCAST_ACTION)</span><br><span class="line">            <span class="comment">// Puts the status into the Intent</span></span><br><span class="line">            .putExtra(Constants.EXTENDED_DATA_STATUS, status);</span><br><span class="line">    <span class="comment">// Broadcasts the Intent to receivers in this app.</span></span><br><span class="line">    LocalBroadcastManager.getInstance(<span class="keyword">this</span>).sendBroadcast(localIntent);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####从<code>IntentService</code>中接收广播状态<br>为了能够接收Intent对象，需要定义一个<code>BroadcastReciver</code>的子类。在该类中，实现<code>BroadcastReceiver</code>的<code>onReceive()</code>回调方法，在接收到一个Intent时<code>LocalBroadcastManager</code>会引用它。<code>LocalBroadcastManager</code>将接收到的Intent传递到<code>BroadcastReceiver</code>的<code>onRecive()</code>方法中。</p>
<p>一旦你定义了<code>BroadcastReceiver</code>，你就可以通过指定动作、类别和数据等过滤信息来匹配它了。为了达到这种效果，你需要创建一个<code>IntentFilter</code>。下面的代码向你展示了如何定义filter：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class that displays photos</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle stateBundle)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">super</span>.onCreate(stateBundle);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// The filter's action is BROADCAST_ACTION</span></span><br><span class="line">        IntentFilter mStatusIntentFilter = <span class="keyword">new</span> IntentFilter(</span><br><span class="line">                Constants.BROADCAST_ACTION);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Adds a data filter for the HTTP scheme</span></span><br><span class="line">        mStatusIntentFilter.addDataScheme(<span class="string">"http"</span>);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>为了在系统中注册<code>BroadcastReceiver</code>和<code>IntentFilter</code>，你需要实例化<code>LocalBroadcastManager</code>并调用其<code>registerReceiver()</code>方法。下例展示的是如何注册<code>BroadcastReceiver</code>和其过滤器的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instantiates a new DownloadStateReceiver</span></span><br><span class="line">     DownloadStateReceiver mDownloadStateReceiver =</span><br><span class="line">             <span class="keyword">new</span> DownloadStateReceiver();</span><br><span class="line">     <span class="comment">// Registers the DownloadStateReceiver and its intent filters</span></span><br><span class="line">     LocalBroadcastManager.getInstance(<span class="keyword">this</span>).registerReceiver(</span><br><span class="line">             mDownloadStateReceiver,</span><br><span class="line">             mStatusIntentFilter);</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure></p>
<p> 一个<code>BroadcastReceiver</code>可以操作多于一种类型的广播Intent对象，每个类型都有自己的操作。这种特征允许你在不同的action中运行代码，不需要为每个action都定义一个<code>BroadcastReceiver</code>。为了为同一个<code>BroadcastReceiver</code>定义其它的<code>IntentFilter</code>，创建<code>IntentFilter</code>并重复调用<code>registerReceiver()</code>。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">       * Instantiates a new action filter.</span><br><span class="line">       * No data filter is needed.</span><br><span class="line">       */</span></span><br><span class="line">      statusIntentFilter = <span class="keyword">new</span> IntentFilter(Constants.ACTION_ZOOM_IMAGE);</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// Registers the receiver with the new filter</span></span><br><span class="line">      LocalBroadcastManager.getInstance(getActivity()).registerReceiver(</span><br><span class="line">              mDownloadStateReceiver,</span><br><span class="line">              mIntentFilter);</span><br></pre></td></tr></table></figure></p>
<p>发送一个广播Intent不会<code>start</code>或者<code>resume</code>一个窗口。即使你的窗口在后台，窗口中的<code>BroadcastReceiver</code>都是可以接收并处理Intent对象的，但并不会强制让你的应用处于前台。当你的窗口处于后台时如果你想向用户通知这个事件，你可以使用<code>Notification</code>。在接收一个广播Intent时是绝不会启动一个窗口的。</p>
<p>##在后台加载数据<br>对于你需要显示的数据，但需要花时间去通过<code>ContentProvider</code>查询时，如果你直接在Activity层面去执行查询操作，可能会严重影响界面的响应速度，比如ANR。就算不会ANR，用户也会明显地感觉到卡顿的现象。为了避免这种问题，你应该在非UI线程里面来初始化查询操作，直到等待它结束后再窗口显示结果。</p>
<p>你可以通过一个对象在后台执行查询同步，待查询结束后更新UI。这个对象就是<code>CursorLoader</code>。除了初始化后台查询外，当查询有变动时<code>CursorLoader</code>会自动地重新查询数据。</p>
<p>这里将向你描述如何通过<code>CursorLoader</code>执行后台查询操作。在代码中用到了<code>V4-SupportLibrary</code>版本的类，它支持V1.6及以上的版本执行此操作。</p>
<p>###通过CursorLoader执行查询操作<br>通过<code>CursorLoader</code>在后台执行同步查询有别于<code>ContentProvider</code>，它会返回结果到调用它的<code>Activity</code>或者<code>FragmentActivity</code>。这样就允许<code>Activity</code>或者<code>FragmentActivity</code>在后台查询数据时可以和用户交互。</p>
<p>####定义一个使用<code>CursorLoader</code>的Activity</p>
<p>为了能够在<code>Activity</code>或者<code>FragmentActivity</code>中使用<code>CursorLoader</code>，需要使用<code>LoaderCallbacks&lt;Cursor&gt;</code>接口，<code>CursorLoader</code>引用接口定义的回调和类进行交互；本课和下一课将详细描述每一个回调。</p>
<p>比如，下面的实例向你展示如何使用依赖库中的<code>CursorLoader</code>定义<code>FragmentActivity</code>。通过扩展<code>FragmentActivity</code>，可以达到通过<code>Fragment</code>使用<code>CursorLoader</code>一样的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoThumbnailFragment</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> <span class="keyword">implements</span></span><br><span class="line">        <span class="title">LoaderManager</span>.<span class="title">LoaderCallbacks</span>&lt;<span class="title">Cursor</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####初始化查询操作</p>
<p>为了初始化查询操作，你需要调用<code>LoadManager</code>的<code>initLoader()</code>方法，它初始化后台框架，你可以在用户进入查询的数据后执行该操作，或者，如果你不需要任何数据，你可以在<code>onCreate()</code>或者<code>onCreateView()</code>中执行该操作，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Identifies a particular Loader being used in this component</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> URL_LOADER = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* When the system is ready for the Fragment to appear, this displays</span><br><span class="line"> * the Fragment's View</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(</span><br><span class="line">        LayoutInflater inflater,</span><br><span class="line">        ViewGroup viewGroup,</span><br><span class="line">        Bundle bundle)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Initializes the CursorLoader. The URL_LOADER value is eventually passed</span><br><span class="line">     * to onCreateLoader().</span><br><span class="line">     */</span></span><br><span class="line">    getLoaderManager().initLoader(URL_LOADER, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：<code>getLoaderManager()</code>方法仅仅适用于Fragment类，为了能够在<code>FragmentActivity</code>中获取<code>LoaderManager</code>，需通过调用<code>getSupportLoaderManager()</code>。</p>
<p>####开始查询</p>
<p>为了能够尽快地初始化后台框架，系统会调用你类中的<code>onCreateLoader()</code>方法，为了能够开始查询，需要从该方法中反馈一个CursorLoader对象。你可以初始化一个空的CursorLoader对象然后通过它来定义查询操作，或者你可以在初始化对象的同时定义查询操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* Callback that's invoked when the system has initialized the Loader and</span><br><span class="line">* is ready to start the query. This usually happens when initLoader() is</span><br><span class="line">* called. The loaderID argument contains the ID value passed to the</span><br><span class="line">* initLoader() call.</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Loader&lt;Cursor&gt; <span class="title">onCreateLoader</span><span class="params">(<span class="keyword">int</span> loaderID, Bundle bundle)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Takes action based on the ID of the Loader that's being created</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">switch</span> (loaderID) &#123;</span><br><span class="line">        <span class="keyword">case</span> URL_LOADER:</span><br><span class="line">            <span class="comment">// Returns a new CursorLoader</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CursorLoader(</span><br><span class="line">                        getActivity(),   <span class="comment">// Parent activity context</span></span><br><span class="line">                        mDataUrl,        <span class="comment">// Table to query</span></span><br><span class="line">                        mProjection,     <span class="comment">// Projection to return</span></span><br><span class="line">                        <span class="keyword">null</span>,            <span class="comment">// No selection clause</span></span><br><span class="line">                        <span class="keyword">null</span>,            <span class="comment">// No selection arguments</span></span><br><span class="line">                        <span class="keyword">null</span>             <span class="comment">// Default sort order</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// An invalid id was passed in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦生成了后台框架的对象，系统就会开始在后台执行查询操作，当查询操作执行完成后，后台框架会调用<code>onLoadFinished()</code>方法。</p>
<p>###处理结果</p>
<p>正如前面所述，你应该在你所实现类的<code>onCreateLoader()</code>方法中通过CursorLoader加载你的数据，加载器会在你Acitivity或者FragmentActivity的<code>LoaderCallbacks.onLoadFinished()</code>方法中返回查询结果。该方法的其中一个入参为包含查询结果的游标。你可以使用这个对象来更新你的数据或者做其它操作。</p>
<p>除了<code>onCreateLoader()</code>和<code>onLoadFinished()</code>方法，你还需要实现<code>onLoaderReset()</code>方法，这个方法会在数据更新更新时被调用，当数据变化时，框架会重新执行当前的查询操作。</p>
<p>####处理查询结果</p>
<p>为了显示从<code>CursorLoader</code>返回的游标数据，你需要自定义一个继承于AdapterView的视图，并为这个视图定义一个继承于<code>CursorAdapter</code>的适配器。然后系统会自动地将数据从游标移到视图。</p>
<p>在你显示任何数据之前你可以为视图和适配器建立连接，然后再<code>onLoadFinished()</code>方法中将游标移到适配器。当你将游标移到适配器后，系统会自动地更新视图。在游标的数据有改动时同样会更新视图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] mFromColumns = &#123;</span><br><span class="line">    DataProviderContract.IMAGE_PICTURENAME_COLUMN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mToFields = &#123;</span><br><span class="line">    R.id.PictureName</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Gets a handle to a List View</span></span><br><span class="line">ListView mListView = (ListView) findViewById(R.id.dataList);</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Defines a SimpleCursorAdapter for the ListView</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line">SimpleCursorAdapter mAdapter =</span><br><span class="line">    <span class="keyword">new</span> SimpleCursorAdapter(</span><br><span class="line">            <span class="keyword">this</span>,                <span class="comment">// Current context</span></span><br><span class="line">            R.layout.list_item,  <span class="comment">// Layout for a single row</span></span><br><span class="line">            <span class="keyword">null</span>,                <span class="comment">// No Cursor yet</span></span><br><span class="line">            mFromColumns,        <span class="comment">// Cursor columns to use</span></span><br><span class="line">            mToFields,           <span class="comment">// Layout fields to use</span></span><br><span class="line">            <span class="number">0</span>                    <span class="comment">// No flags</span></span><br><span class="line">    );</span><br><span class="line"><span class="comment">// Sets the adapter for the view</span></span><br><span class="line">mListView.setAdapter(mAdapter);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Defines the callback that CursorLoader calls</span><br><span class="line"> * when it's finished its query</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFinished</span><span class="params">(Loader&lt;Cursor&gt; loader, Cursor cursor)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Moves the query results into the adapter, causing the</span><br><span class="line">     * ListView fronting this adapter to re-display</span><br><span class="line">     */</span></span><br><span class="line">    mAdapter.changeCursor(cursor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####删除旧的游标信息<br>当游标非法时<code>CursorLoader</code>会被重置，这多数情况发生在游标的数据有改动时，在重新执行查询操作前，框架会调用你所实现的<code>onLoaderReset()</code>方法。在这个回调中，你应该删除当前游标的所有信息来避免内存泄露。一旦结束回调<code>onLoaderReset()</code>方法后，<code>CursorLoader</code>会重新执行查询操作。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Invoked when the CursorLoader is being reset. For example, this is</span><br><span class="line"> * called if the data in the provider changes and the Cursor becomes stale.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onLoaderReset(Loader&lt;Cursor&gt; loader) &#123;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * Clears out the adapter&apos;s reference to the Cursor.</span><br><span class="line">     * This prevents memory leaks.</span><br><span class="line">     */</span><br><span class="line">    mAdapter.changeCursor(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##管理设备的激活状态</p>
<p>当一个android设备处于空闲状态时，它首先会变暗，然后会关屏，最终会让CPU停止工作。这样处理是为了避免设备的电池被快速地耗尽，然而有些时候你的应用需要一些不同的表现：</p>
<p>（1）游戏或者电影应用可能需要保持屏幕常亮；</p>
<p>（2）有些应用虽然不需要屏幕常亮，但在CPU执行完核心操作之前同样需要保持程序运行。</p>
<p>本节的目的是告诉你在避免电池被快速耗尽的情况下如何保持设备处于激活状态。</p>
<p>###保持设备处于激活状态</p>
<p>为了避免电池被耗尽，android设备会在处于空闲状态时立即切换到休眠状态。然而，有些时候一个应用需要保持屏幕常亮或者CPU直到某些事情被处理完成。<br>你该采取什么操作取决于你应用的需求。然而，通用的规则是你应该使用最轻量级的操作来处理你的应用程序，使你的应用减少对系统资源的占用。下面将向你描述通过怎样地操作来使得你对应用的处理和系统默认的休眠行为相容。</p>
<p>####保持屏幕常亮<br>某些应用需要保持屏幕常亮，比如游戏或者电影应用。最好的方式是在你的窗口中使用<code>FLAG_KEEP_SCREEN_ON</code>属性（只在一个窗口，绝不是在一个服务或者其它应用组件中），比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这种先进的处理方式有别于唤醒锁，它不需要特殊的权限，平台会正确地管理应用之间的切换，你不需要担心自己的应用没有释放没有使用的资源。</p>
<p>实现该功能的另一种思路是在你应用xml文件中使用<code>android:keepScreenOn</code>属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:keepScreenOn=&quot;true&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>andorid:keepScreenOn=”true”</code>和使用<code>FLAG_KEEP_SCREEN_ON</code>是一样的效果。你可以使用适合于你应用的任何一种方式。通过在程序中设置你窗口常亮状态的优势是：它可以清楚这个标志，从而可以关闭屏幕。</p>
<p>####保持CPU持续工作<br>如果你希望在设备休眠之前CPU能够完成需要处理的工作，你可以使用一个叫唤醒锁的<code>PowerManager</code>系统服务。唤醒锁允许你的应用可以控制主机设备电源的状态。</p>
<p>创建和保持唤醒锁会在一定程度上对电池的寿命有所影响，因此你应该只在非常有必要的情况下使用它，并尽量控制使用时间。比如，你绝不应该在一个窗口中使用唤醒锁，正如上面所描述的那样，如果你想保持当前窗口的屏幕常亮，你可以使用<code>FLAG_KEEP_SCREEN_ON</code>。</p>
<p>应该使用唤醒锁的情况可能就是后台服务在屏幕关闭时需要通过唤醒锁保持CPU持续工作。再次声明，尽量限制它的使用时间，因为它会影响到电池的寿命。</p>
<p>为了使用唤醒锁，首先需要在清单文件中添加<code>WAKE_LOCK</code>权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果你的应用包含一个使用服务处理某些事情的广播接收器，你可以通过<code>WakefulBroadcastReceiver</code>来管理你的唤醒锁，正如使用<code>WakefulBroadcastReceiver</code>一课中所描述的那样，这是一个比较好的处理方式。如果你的应用没有遵循这种方式，通过下面的代码你可以直接设置唤醒锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);</span><br><span class="line">Wakelock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,</span><br><span class="line">        &quot;MyWakelockTag&quot;);</span><br><span class="line">wakeLock.acquire();</span><br></pre></td></tr></table></figure></p>
<p>为了释放唤醒锁，你需要调用wakelock的release()方法。它将释放你对CPU的声明，在你的应用结束工作后尽快关闭唤醒锁避免电池被耗尽。</p>
<p>####使用WakefulBroadcastReceiver<br>使用广播接收器和服务可以让你很好地管理后台任务的生命周期。</p>
<p>一个<code>WakefulBroadcastReceiver</code>是广播接收器的一个特殊类型，它可以创建和管理你应用的<code>PARITAL_WAKE_LOCK</code>。一个<code>WakeBroadcastReceiver</code>接收到广播后将工作传递给Service（一个典型的IntentService），直到确保设备没有休眠。如果你在交接工作给服务的时候没有保持唤醒锁，在工作还没完成之前就允许设备休眠的话，将会出现一些你不愿意看到的情况。</p>
<p>要使用<code>WakefulBroadcastReceiver</code>的第一步是在manifest文件中添加它，和其它广播接收器是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.MyWakefulReceiver&quot;&gt;&lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p>
<p>接下来是在代码中通过<code>startWakefulService()</code>来启动<code>MyIntentService</code>。和<code>starService()</code>方法相比，除了在服务启动时可以保持唤醒锁外，通过<code>startWakefulService()</code>方法传递的Intent可以保持一个额外的唤醒锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyWakefulReceiver extends WakefulBroadcastReceiver &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">        // Start the service, keeping the device awake while the service is</span><br><span class="line">        // launching. This is the Intent to deliver to the service.</span><br><span class="line">        Intent service = new Intent(context, MyIntentService.class);</span><br><span class="line">        startWakefulService(context, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当服务执行完成后，系统会调用<code>MyWakefulReceiver</code>的<code>completeWakefulIntent()</code>方法来释放唤醒锁，<code>completeWakefulIntent()</code>方法携带的参数是从<code>WakefulBroadcastReceiver</code>传递过来的intent:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyIntentService extends IntentService &#123;</span><br><span class="line">    public static final int NOTIFICATION_ID = 1;</span><br><span class="line">    private NotificationManager mNotificationManager;</span><br><span class="line">    NotificationCompat.Builder builder;</span><br><span class="line">    public MyIntentService() &#123;</span><br><span class="line">        super(&quot;MyIntentService&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onHandleIntent(Intent intent) &#123;</span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        // Do the work that requires your app to keep the CPU running.</span><br><span class="line">        // ...</span><br><span class="line">        // Release the wake lock provided by the WakefulBroadcastReceiver.</span><br><span class="line">        MyWakefulReceiver.completeWakefulIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###调度重复性警报</p>
<p>Alarms（基于AlarmManager类）给你一种方式来执行应用生命周期之外的基于时间的操作。例如，你可以使用一个alarm去初始化一个长时间运行的操作。比如开启一个服务一天一次去下载一个天气预报。</p>
<p>Alarms有这些特点：</p>
<ul>
<li>它使你发送Intents在固定的时间或者时间间隔</li>
<li>您可以使用它们结合广播接收器去开始服务和执行其他操作</li>
<li>他们的操作范畴在应用程序之外，所以你可以使用它们来触发事件或动作，即使应用程序没有运行，即使该设备本身是睡眠状态</li>
<li>他们帮助你减少你的应用的资源需求。你可以不依赖定时器或连续运行后台服务去安排操作</li>
</ul>
<p>####理解Trade-offs</p>
<p>一个重复报警是一个具有有限灵活性的相对简单的机制。对我们的应用，它可能不是最好的选择，特别是如果您需要触发网络操作。一个设计糟糕的alarm会导致电池消耗，给服务器增加了负担。</p>
<p>在应用生命周期外触发一个操作的常见场景是跟服务器段同步数据。在这种情况下，你可能想使用一个重复性alarm，但是你的服务器使用谷歌云存储消息传递（GCM）结合同步适配器要比 AlarmManager好很多，一个同步适配器提供给你像AlarmManager一样的调度选项，但是它提供了更多的灵活性。例如，一个同步可以是基于“新数据”从服务端或者设备，用户的不同activity，一天中的不同时间，或者其他。</p>
<p><strong>最佳实践</strong></p>
<p>当你在设计你的一个重复性的alarm时，你的任何选择都可能影响你的app使用（或者说是滥用）系统资源。例如，假设一个受欢迎的应用程序与服务器同步，如果同步操作是基于时钟时间，每个app的实例在晚上11点同步。服务器上的负载可能会高负载甚至导致“拒绝服务”，使用alarm时遵循这些最佳实践:</p>
<ul>
<li>使用重复性alarm触发网络请求时添加随机性：<ol>
<li>当alarm触发时，做一些本地处理，意思就是不连接服务器或者向服务器请求数据。</li>
<li>同时，安排包含有网络请求的alarm在一个随机时间段内触发。</li>
</ol>
</li>
<li>使alarm频率最低</li>
<li>不要在不必要的时候唤醒设备</li>
<li>不要使你的alarm触发时间过于精确</li>
<li>尽可能避免基于时钟时间的alarm</li>
</ul>
<p>####设置一个重复性alarm</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台，多线程/">后台，多线程</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/译文/">译文</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-effects-of-android-application-termination" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/05/effects-of-android-application-termination/" class="article-date">
  	<time datetime="2014-07-04T16:51:24.000Z" itemprop="datePublished">2014-07-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/05/effects-of-android-application-termination/">Android应用程序终止的影响</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>透过ActivityManagerService来查看程序是如何被关闭的</p>
<p>在一般的系统进程管理和用户操作之间，还有少数一些方法能够使我们的程序终止。作为一个开发者，你的代码可能会产生一些附加效果，我们来看看一下终止应用的方法产生的影响：</p>
<ul>
<li>内存压力（即lowmemorykiller）杀掉一个进程</li>
<li>用户从最近使用的程序展示项中滑动移除任务</li>
<li>用户从系统设置处强制关闭应用</li>
</ul>
<p>##Foreground vs. Background<br>在我们进一步讨论之前，我们需要先简单说下Android是如何看待前台和后台状态的。一般来说，当前对用户可见的，可交互的应用被称之为前台应用。系统中其他的应用被认为处于后台状态。低内存清理模块可能无法平等的看待<a href="https://github.com/android/platform_frameworks_base/blob/android-4.4.3_r1/services/java/com/android/server/am/ProcessList.java#L47-104" target="_blank" rel="external">后台状态</a>，但是鉴于讨论这个问题，姑且认为是同等看待的。</p>
<p>服务对象可以被标记为“前台服务”，其唯一活跃的用户界面是由一个在系统窗口一直存在的notification组成。在这种特殊的情况下，应用进程被给予了很高的等级（特别是PERCEPTIBLE_APP_ADJ，值为2，值越低优先级越高），即使它没有任何可以跟用户交互的界面，虽然不能完全等同与一个可见的程序，但是这里我们认为它使得所有进程都处于前台状态。</p>
<p>技术上而言，我所指的是进程所在的“调度组”，这不同于出于内存压力需要而去关闭进程时用于排序的数值，系统服务使用这种区分来管理涉及到清除进程的行为。这很重要，需要记住。</p>
<p>##比较对照</p>
<table>
<thead>
<tr>
<th>行为</th>
<th style="text-align:right">低内存清理</th>
<th style="text-align:right">清除最近任务</th>
<th style="text-align:right">强制关闭</th>
</tr>
</thead>
<tbody>
<tr>
<td>进程终止</td>
<td style="text-align:right">Y</td>
<td style="text-align:right">Y1</td>
<td style="text-align:right">Y</td>
</tr>
<tr>
<td>PendingIntent可触发</td>
<td style="text-align:right">Y</td>
<td style="text-align:right">Y</td>
<td style="text-align:right">N</td>
</tr>
<tr>
<td>接收广播可以启动程序</td>
<td style="text-align:right">Y</td>
<td style="text-align:right">Y</td>
<td style="text-align:right">N</td>
</tr>
<tr>
<td>Activity栈保存</td>
<td style="text-align:right">Y</td>
<td style="text-align:right">N</td>
<td style="text-align:right">N</td>
</tr>
</tbody>
</table>
<p>Y1:这个终止不能保证，详见下文</p>
<p>##低内存清理<br>这种情况在Android系统中会阶段性发生，且用户无察觉，当系统内存不足时，它会关闭一些进程以回收资源。这么做是为了尽量少的对用户产生影响。所以，当程序进程被终止，外部事件（比如一个广播）会再次启动这个进程。程序甚至会保存在最近使用页面以方便用户再次打开。此外，进程被终止时存在的所有的Activity的栈都会被保留，当用户把应用重新切到前台的时候，他们会被重现。理论上，在第一时间终止应用进程对用户是而言是隐性的。</p>
<p>##清除最近任务<br><img src="http://www.doubleencore.com/wp-content/uploads/2014/05/Swipe1.gif" alt="2"></p>
<p>当用户在最近任务页面清除掉一个应用时，产生的行为有些不同。在这种情况下，系统会认为用户不希望此应用状态被保留。此程序进程分配的Activity栈也会被清理。下一次打开应用会开启一个全新的任务。跟上边一样，从其他应用和服务发来的行为可以唤醒并重启此应用进程。</p>
<p>此外，如果进程当时处于一个后台状态的话，那只会终止进程。这通常被认为是正确的，因为一个前台的Activity栈在最近任务页面显示且活跃时也会被暂时切入后台。然而，如果是一个活跃的前台服务的情况下，终止进程的行为会被阻止。在后边会描述为什么这样。</p>
<p>然而这确实意味着，后台运行的服务不能阻止这个级别的进程终止。为了帮助过渡，服务类通过onTaskRemoved()方法提供了一个回调，可以在服务被强制关闭之前记录或处理一些关键的东西。注意，这个回调特定于这种用例，低内存清理时是没有这个回调的。</p>
<p>##强制关闭<br><img src="http://www.doubleencore.com/wp-content/uploads/2014/05/ForceStop.gif" alt="3"><br>最后这种情况是指用户进入系统设置页面，强制要求关闭某个应用。很多人认为这跟之前的方式是一样的。但这里有些需要特别注意，首先就是不管进程是不是后台状态，用户强制关闭时，进程一定会被终止。</p>
<p>除此之外，系统服务中关于此进程的记录都会被标记成”关闭状态”，这意味着没有外部触发可以唤醒整个应用进程。在用户再次主动的开发它之前，这个进程是被孤立的。就跟用户刚安装了应用且一次都没打开过一样的状态。</p>
<p>##一个有趣的边界情况</p>
<p>不可避免的是，随着Android进程管理的不断进步，复杂性的提升会导致一些未知的状态。其中一个例子就是在<a href="https://code.google.com/p/android/issues/detail?id=63618#c22" target="_blank" rel="external">一个bug报告的评论里</a>，这里描述的行为是当应用正在运行一个前台服务，任务被滑动取消了，进程依然保持运行状态，但是它很容易被外部触发给搞死。</p>
<p>这么做的原因在于当前<code>ActivityManagerService</code>是如何管理这些事件的。当收到一个请求，需要清理某一个app的任务，如果进程被认为是后台的，服务会直接终止进程。如果是在前台，那服务会延迟一会才会被终止。推测这是为了让把工作做完后才终止，或者从前台状态转变成其他。</p>
<p>在<code>ActivityManagerService.computeOomAdjLocked()</code>方法中，进程的前后台状态的重新评定都会检查标记值。这就跟系统事件一样，不断的在发生，这个小例子的关键问题看起来像是在<code>ActivityManagerService</code>中的<a href="https://github.com/android/platform_frameworks_base/blob/android-4.4.3_r1/services/java/com/android/server/am/ActivityManagerService.java#L14313-L14357" target="_blank" rel="external">一段代码</a>中，它用于评估不同的事件条件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (app == TOP_APP) &#123;</span><br><span class="line">            <span class="comment">// The last app on the list is the foreground app.</span></span><br><span class="line">            adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">            schedGroup = Process.THREAD_GROUP_DEFAULT;</span><br><span class="line">            app.adjType = <span class="string">"top-activity"</span>;</span><br><span class="line">            foregroundActivities = <span class="keyword">true</span>;</span><br><span class="line">            interesting = <span class="keyword">true</span>;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_TOP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.instrumentationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Don't want to kill running instrumentation.</span></span><br><span class="line">            adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">            schedGroup = Process.THREAD_GROUP_DEFAULT;</span><br><span class="line">            app.adjType = <span class="string">"instrumentation"</span>;</span><br><span class="line">            interesting = <span class="keyword">true</span>;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((queue = isReceivingBroadcast(app)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// An app that is currently receiving a broadcast also</span></span><br><span class="line">            <span class="comment">// counts as being in the foreground for OOM killer purposes.</span></span><br><span class="line">            <span class="comment">// It's placed in a sched group based on the nature of the</span></span><br><span class="line">            <span class="comment">// broadcast as reflected by which queue it's active in.</span></span><br><span class="line">            adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">            schedGroup = (queue == mFgBroadcastQueue)</span><br><span class="line">                    ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">            app.adjType = <span class="string">"broadcast"</span>;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_RECEIVER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.executingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// An app that is currently executing a service callback also</span></span><br><span class="line">            <span class="comment">// counts as being in the foreground.</span></span><br><span class="line">            adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">            schedGroup = app.execServicesFg ?</span><br><span class="line">                    Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">            app.adjType = <span class="string">"exec-service"</span>;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line">            <span class="comment">//Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// As far as we know the process is empty.  We may change our mind later.</span></span><br><span class="line">            schedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">            <span class="comment">// At this point we don't actually know the adjustment.  Use the cached adj</span></span><br><span class="line">            <span class="comment">// value that the caller wants us to.</span></span><br><span class="line">            adj = cachedAdj;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">            app.cached = <span class="keyword">true</span>;</span><br><span class="line">            app.empty = <span class="keyword">true</span>;</span><br><span class="line">            app.adjType = <span class="string">"cch-empty"</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过代码可以看到，一个接收广播的活动在检查是否有前台服务之前就被评定了。如果应用程序在接收标准广播的过程（即一个没有flag_receiver_foreground标志），该过程将被设置为后台状态，代码不会继续执行验证是否有前台服务正在运行。</p>
<p>总结，导致意外的情况：</p>
<ol>
<li>程序启动了一个前台服务</li>
<li>用户将程序切到后台（程序仍在前台集合里，因为服务）</li>
<li>用户滑动清除了任务，当状态改变时，进程会被杀死</li>
<li>接收到广播事件，ActivityManagerService更新程序进程的状态来处理广播</li>
<li>在这么做时， ActivityManagerService把进程移到后台，因为广播事件中不包含前台标示。</li>
<li>在这种情况下，ActivityManagerService跳过了前台服务的检测。</li>
<li>在同一地方，如果进程被标记为死亡或者后台组，检测返回为TRUE。</li>
</ol>
<p><a href="http://www.doubleencore.com/2014/06/effects-android-application-termination/" target="_blank" rel="external">原文地址</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/译文/">译文</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-header-first-builder" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/03/header-first-builder/" class="article-date">
  	<time datetime="2014-07-03T14:31:07.000Z" itemprop="datePublished">2014-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/03/header-first-builder/">Android 设计模式--建造者模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##简述</p>
<p>建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</p>
<p><img src="http://my.csdn.net/uploads/201203/25/1332654150_2478.jpg" alt="此处输入图片的描述"></p>
<ul>
<li>建造者（Builder）角色：给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者（Concrete Builder）角色。具体建造者类必须实现这个接口所要求的方法：一个是建造方法，另一个是结果返还方法。</li>
<li>具体建造者（Concrete Builder）角色：担任这个角色的是于应用程序紧密相关的类，它们在应用程序调用下创建产品实例。这个角色主要完成的任务包括：实现Builder角色提供的接口，一步一步完成创建产品实例的过程。在建造过程完成后，提供产品的实例。</li>
<li>指导者（Director）角色：担任这个角色的类调用具体建造者角色以创建产品对象。导演者并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者对象。</li>
<li>产品（Product）角色：产品便是建造中的复杂对象。指导者角色是于客户端打交道的角色。导演者角色将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体建造者角色。具体建造者角色是做具体建造工作的，但却不为客户端所知。</li>
</ul>
<p>综合网上各类文章的描述，较为通俗的一种是房屋建造的例子：我的目的是要一座房子，可是我不知道怎么盖，也不知道怎么样设计（建几个房间，几个门），于是我需要找一帮民工，他们会基本的工作，即砌墙，装门等，，还得找个设计师，他知道怎么设计，我需要确保民工听设计师的领导，而设计师本身不干活，只是指挥民工，这里砌一堵墙，这里砌一扇门，这样民工开始建设，最后，我可以向民工要房子了。在这个过程中，设计师是什么也没有，除了他在脑子里的设计和命令，所以要房子也是跟民工要。</p>
<p>##代码描述<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品（Product）角色</span></span><br><span class="line"><span class="comment">// 首先是房子类，主要是需要描述一下房屋属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span>  String window;  </span><br><span class="line">  <span class="keyword">private</span>  String floor;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建造者（Builder）角色</span></span><br><span class="line"><span class="comment">// 工人接口，定义了各个工人所要进行的工作。负责进行具体部件如窗户，地板的建造。</span></span><br><span class="line"><span class="comment">// 同时因为房子是民工建的，因此建设完成后由他把房子递交回房主</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">makeWindow</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">makeFloor</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span>  Room  <span class="title">getRoom</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指导者（Director）角色</span></span><br><span class="line"><span class="comment">// 设计师。他知道房子应该怎么设计，但他不会自己去建造，而是指挥工人建造。  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Designer</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 指挥民工进行工作  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">(Builder  builder)</span> </span>&#123;  </span><br><span class="line">    builder.makeWindow();  </span><br><span class="line">    builder.makeFloor();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体建造者（Concrete Builder）角色</span></span><br><span class="line"><span class="comment">// 工人, 负责进行具体部件如窗户，地板的建造。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>  <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span>  Room room = <span class="keyword">new</span> Room();  </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">makeWindow</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    room.window =<span class="keyword">new</span> String(<span class="string">"window"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">makeFloor</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    room.floor = <span class="keyword">new</span> String(<span class="string">"floor"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 回交房子给房主  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  Room  <span class="title">getRoom</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> room;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我获取房子的流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">     Builder worker = <span class="keyword">new</span> Worker(); <span class="comment">//获取工人对象   </span></span><br><span class="line">     Designer  designer = <span class="keyword">new</span>  Designer();   <span class="comment">//获取设计师对象 </span></span><br><span class="line">     designer.order(worker);    <span class="comment">//设计师指挥工人工作</span></span><br><span class="line">     worker.getRoom();   <span class="comment">//工人交房 </span></span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##Android中的体现<br>在Android中的体现，常见是就是AlertDialog.buider, Notification.builder。简单看下AlertDialog的部分代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AlertDialog</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertDialog</span> <span class="keyword">extends</span> <span class="title">Dialog</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Controller, 接受Builder成员变量P中的各个参数</span></span><br><span class="line">    <span class="keyword">private</span> AlertController mAlert;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AlertDialog</span><span class="params">(Context context, <span class="keyword">int</span> theme)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, theme, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 4 : 构造AlertDialog</span></span><br><span class="line">    AlertDialog(Context context, <span class="keyword">int</span> theme, <span class="keyword">boolean</span> createContextWrapper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context, resolveDialogTheme(context, theme), createContextWrapper);</span><br><span class="line">        mWindow.alwaysReadCloseOnTouchAttr();</span><br><span class="line">        mAlert = <span class="keyword">new</span> AlertController(getContext(), <span class="keyword">this</span>, getWindow());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 实际上调用的是mAlert的setTitle方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setTitle(title);</span><br><span class="line">        mAlert.setTitle(title);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 实际上调用的是mAlert的setCustomTitle方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomTitle</span><span class="params">(View customTitleView)</span> </span>&#123;</span><br><span class="line">        mAlert.setCustomTitle(customTitleView);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(CharSequence message)</span> </span>&#123;</span><br><span class="line">        mAlert.setMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// AlertDialog其他的代码省略</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// ************  Builder为AlertDialog的内部类   *******************</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 : 存储AlertDialog的各个参数, 例如title, message, icon等.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AlertController.AlertParams P;</span><br><span class="line">        <span class="comment">// 属性省略</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Constructor using a context for this builder and the &#123;<span class="doctag">@link</span> AlertDialog&#125; it creates.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(context, resolveDialogTheme(context, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context, <span class="keyword">int</span> theme)</span> </span>&#123;</span><br><span class="line">            P = <span class="keyword">new</span> AlertController.AlertParams(<span class="keyword">new</span> ContextThemeWrapper(</span><br><span class="line">                    context, resolveDialogTheme(context, theme)));</span><br><span class="line">            mTheme = theme;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// Builder的其他代码省略 ......</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2 : 设置各种参数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setTitle</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">            P.mTitle = title;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMessage</span><span class="params">(CharSequence message)</span> </span>&#123;</span><br><span class="line">            P.mMessage = message;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setIcon</span><span class="params">(<span class="keyword">int</span> iconId)</span> </span>&#123;</span><br><span class="line">            P.mIconId = iconId;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setPositiveButton</span><span class="params">(CharSequence text, <span class="keyword">final</span> OnClickListener listener)</span> </span>&#123;</span><br><span class="line">            P.mPositiveButtonText = text;</span><br><span class="line">            P.mPositiveButtonListener = listener;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            P.mView = view;</span><br><span class="line">            P.mViewSpacingSpecified = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 3 : 构建AlertDialog, 传递参数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AlertDialog <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用new AlertDialog构造对象， 并且将参数传递个体AlertDialog </span></span><br><span class="line">            <span class="keyword">final</span> AlertDialog dialog = <span class="keyword">new</span> AlertDialog(P.mContext, mTheme, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 5 : 将P中的参数应用的dialog中的mAlert对象中</span></span><br><span class="line">            P.apply(dialog.mAlert);</span><br><span class="line">            dialog.setCancelable(P.mCancelable);</span><br><span class="line">            <span class="keyword">if</span> (P.mCancelable) &#123;</span><br><span class="line">                dialog.setCanceledOnTouchOutside(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</span><br><span class="line">            <span class="keyword">if</span> (P.mOnKeyListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dialog;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，通过Builder来设置AlertDialog中的title, message, button等参数， 这些参数都存储在类型为AlertController.AlertParams的成员变量P中，AlertController.AlertParams中包含了与之对应的成员变量。在调用Builder类的create函数时才创建AlertDialog, 并且将Builder成员变量P中保存的参数应用到AlertDialog的mAlert对象中，即P.apply(dialog.mAlert)代码段。我们看看apply函数的实现 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(AlertController dialog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCustomTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setCustomTitle(mCustomTitleView);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dialog.setTitle(mTitle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dialog.setIcon(mIcon);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIconId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            dialog.setIcon(mIconId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIconAttrId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setMessage(mMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPositiveButtonText != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,</span><br><span class="line">                mPositiveButtonListener, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNegativeButtonText != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,</span><br><span class="line">                mNegativeButtonListener, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNeutralButtonText != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,</span><br><span class="line">                mNeutralButtonListener, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mForceInverseBackground) &#123;</span><br><span class="line">        dialog.setInverseBackgroundForced(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For a list, the client can either supply an array of items or an</span></span><br><span class="line">    <span class="comment">// adapter or a cursor</span></span><br><span class="line">    <span class="keyword">if</span> ((mItems != <span class="keyword">null</span>) || (mCursor != <span class="keyword">null</span>) || (mAdapter != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        createListView(dialog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mViewSpacingSpecified) &#123;</span><br><span class="line">            dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,</span><br><span class="line">                    mViewSpacingBottom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dialog.setView(mView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上就是把P中的参数挨个的设置到AlertController中， 也就是AlertDialog中的mAlert对象。从AlertDialog的各个setter方法中我们也可以看到，实际上也都是调用了mAlert对应的setter方法。在这里，Builder同时扮演了上文中提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。</p>
<p>##优点</p>
<ul>
<li>良好的封装性， 使用建造者模式可以使客户端不必知道产品内部组成的细节。</li>
<li>每一个Builder都相对独立，而与其它的Builder无关。 </li>
<li>可使对构造过程更加精细控制。</li>
<li>将构建代码和表示代码分开。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/笔记/">笔记</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-creating-a-cards-ui" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/06/05/creating-a-cards-ui/" class="article-date">
  	<time datetime="2014-06-04T17:03:32.000Z" itemprop="datePublished">2014-06-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/05/creating-a-cards-ui/">在Android中创建卡片式UI</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>自从Google首次在Google+中推出了卡片式UI，卡片式变得越来越受欢迎。每个人都喜欢这种样式，并在自己的软件里实现类似的概念。它不仅可用于时尚的图形展示，也提供相应的逻辑功能，每个卡片都有它自己的内容和作用于内容的行为逻辑。换句话说，每个卡片都有自己的内容管理。<br><img src="http://www.technology-ebay.de/data/mediapool/my_ads_example.png" alt="此处输入图片的描述"></p>
<p>当我们开始为易趣Kleinanzeigen程序考虑预定功能时，最大的问题就是这个功能的入口点应该放在哪里，最后我们决定最好的方式就是在用户广告列表采用卡片界面。这样，每个广告通过”Promote”按钮可以增强本身的作用。</p>
<p>在这片文章中，我将试着使用listview adapter来创建卡片式界面。</p>
<p>##首先是布局</p>
<p>布局包含一个listview，外层包含一个LinearLayout，背景为灰色。Listview包含10dip的padding，10dip的透明分隔线，另外，列表项背景色为白色，这样他们能各自区分出来，更像是一个卡片。这里是布局代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">    xmlns:tools="http://schemas.android.com/tools"</span><br><span class="line">    android:layout_width="match_parent"</span><br><span class="line">    android:layout_height="match_parent"</span><br><span class="line">    android:background="@color/light_grey" &gt;</span><br><span class="line"> </span><br><span class="line">    &lt;ListView</span><br><span class="line">        android:id="@+id/cards_list"</span><br><span class="line">        android:layout_width="match_parent"</span><br><span class="line">        android:layout_height="wrap_content"</span><br><span class="line">        android:clipToPadding="false"</span><br><span class="line">        android:divider="@android:color/transparent"</span><br><span class="line">        android:dividerHeight="10dp"</span><br><span class="line">        android:padding="10dp"</span><br><span class="line">        android:scrollbarStyle="outsideOverlay"</span><br><span class="line">        tools:listitem="@layout/list_item_card" /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>有关ListView的一个细节实际上很重要，clipToPadding属性应该被设置成false（默认情况是TRUE），否则的话，Listview的内容区不会滚动到padding区域，下图可以直观的解释：<br><img src="http://www.technology-ebay.de/data/mediapool/clip_to_padding_diff.png" alt="此处输入图片的描述"></p>
<p>另一个重要的地方是scrollbarStyle属性，我们设置为”outsideOverlay”以使不出现叠加到卡片的情况，这出现在Listview的边缘，忽略padding。</p>
<p>列表项的设计源于我们的内容，在这里，我添加了一个文本，两个功能按钮，白色背景。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">    android:layout_width="match_parent"</span><br><span class="line">    android:layout_height="match_parent"</span><br><span class="line">    android:background="@drawable/selectable_background"</span><br><span class="line">    android:orientation="vertical" &gt;</span><br><span class="line"> </span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id="@+id/list_item_card_text"</span><br><span class="line">        style="@style/ListItemText"</span><br><span class="line">        android:layout_width="match_parent"</span><br><span class="line">        android:layout_height="wrap_content" /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;View</span><br><span class="line">        android:id="@+id/list_item_seperator"</span><br><span class="line">        android:layout_width="match_parent"</span><br><span class="line">        android:layout_height="1dip"</span><br><span class="line">        android:layout_marginLeft="5dip"</span><br><span class="line">        android:layout_marginRight="5dip"</span><br><span class="line">        android:background="@color/light_grey" /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        style="?android:attr/buttonBarStyle"</span><br><span class="line">        android:layout_width="match_parent"</span><br><span class="line">        android:layout_height="wrap_content" &gt;</span><br><span class="line"> </span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id="@+id/list_item_card_button_1"</span><br><span class="line">            style="?android:attr/buttonBarButtonStyle"</span><br><span class="line">            android:layout_width="match_parent"</span><br><span class="line">            android:layout_height="wrap_content"</span><br><span class="line">            android:layout_margin="5dip"</span><br><span class="line">            android:layout_weight="1"</span><br><span class="line">            android:focusable="false"</span><br><span class="line">            android:focusableInTouchMode="false"</span><br><span class="line">            android:text="@string/list_item_left_button"</span><br><span class="line">            android:textSize="12sp"</span><br><span class="line">            android:textStyle="normal" /&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id="@+id/list_item_card_button_2"</span><br><span class="line">            style="?android:attr/buttonBarButtonStyle"</span><br><span class="line">            android:layout_width="match_parent"</span><br><span class="line">            android:layout_height="wrap_content"</span><br><span class="line">            android:layout_margin="5dip"</span><br><span class="line">            android:layout_weight="1"</span><br><span class="line">            android:focusable="false"</span><br><span class="line">            android:focusableInTouchMode="false"</span><br><span class="line">            android:text="@string/list_item_right_button"</span><br><span class="line">            android:textSize="12sp"</span><br><span class="line">            android:textStyle="normal" /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>##回归代码</p>
<p>代码部分的设计也很简单，包含几个重要或者棘手的部分，我更喜欢先创建adapter以备Listview初始化时传入。我只是继承BaseAdapter，在getView方法里初始化列表项布局，初始化文本控件和功能按钮，重要的部分是如何给按钮设置点击监听事件，因为adapter采用回收机制，非常容易发生的是，如果一个OnClickListener被设置在adapter内部，下一个复用的列表项会使用完全相同的onClickListener，数据却是不同的，在适配器逻辑中，每个列表项都有同样的元素，同样的View Id，因此，不可能根据ID知道哪个列表项的按钮被点击了。</p>
<p>在这一点上，我们最好在将adapter设置到Listview的地方设置回调，要做到这一点，我在Adapter的构造函数里接收一个View.OnClickListener，保存为适配器的一个变量，并设置给按钮。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CardsAdapter</span><span class="params">(Context context, List&lt;String&gt; items, OnClickListener itemButtonClickListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">        <span class="keyword">this</span>.itemButtonClickListener = itemButtonClickListener;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        ViewHolder holder;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            convertView = LayoutInflater.from(context).inflate(R.layout.list_item_card, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">            holder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">            holder.itemText = (TextView) convertView.findViewById(R.id.list_item_card_text);</span><br><span class="line">            holder.itemButton1 = (Button) convertView.findViewById(R.id.list_item_card_button_1);</span><br><span class="line">            holder.itemButton2 = (Button) convertView.findViewById(R.id.list_item_card_button_2);</span><br><span class="line">            convertView.setTag(holder);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            holder = (ViewHolder) convertView.getTag();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        holder.itemText.setText(items.get(position));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (itemButtonClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            holder.itemButton1.setOnClickListener(itemButtonClickListener);</span><br><span class="line">            holder.itemButton2.setOnClickListener(itemButtonClickListener);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> convertView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>##棘手的部分</p>
<p>在Fragment或者Activity中，我们初始化包含Listview的布局，初始化Listview实例，然后设置适配器，最后我们传一个View.OnclickListener对象到适配器的构造函数里，我们不需要去在意未显示的列表项，因为他们在窗口之外不可能被点击。</p>
<p>在View.OnClickListener中重写onClick方法，我简单的遍历当前可见的列表项，借助方法为getFirstVisiblePosition()和getLastVisiblePosition()。然后检查点击的按钮是否属于当前迭代的那一项。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItemButtonClickListener</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cardsList.getFirstVisiblePosition(); i &lt;= cardsList.getLastVisiblePosition(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == cardsList.getChildAt(i - cardsList.getFirstVisiblePosition()).findViewById(R.id.list_item_card_button_1)) &#123;</span><br><span class="line">                    <span class="comment">// PERFORM AN ACTION WITH THE ITEM AT POSITION i</span></span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Clicked on Left Button of List Item "</span> + i, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v == cardsList.getChildAt(i - cardsList.getFirstVisiblePosition()).findViewById(R.id.list_item_card_button_2)) &#123;</span><br><span class="line">                    <span class="comment">// PERFORM ANOTHER ACTION WITH THE ITEM AT POSITION i</span></span><br><span class="line">                    Toast.makeText(getActivity(), <span class="string">"Clicked on Right Button of List Item "</span> + i, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>关键点在于当ListView.getFirstVisiblePosition()或ListView.getLastVisiblePosition()方法返回给我们列表内的精确索引时，ListView.getChildAt方法返回给我们在可见区域内的索引位置，例如，firstVisiblePosition是3，getChildAt(3)会返回列表的第6个元素。</p>
<p>另外，我添加了一个OnItemClickListener到ListView，用于当列表项的内容被点击时做一些事情，比如跳转到详情页。</p>
<p>##结果</p>
<p>最后,我们得到一个简单的列表视图的外观和感觉的卡片UI。也许我们可以添加更多的元素。</p>
<p>这个示例的完整代码可以在<a href="https://github.com/vudin/android-cards-ui-example" target="_blank" rel="external">GitHub</a>上找到。</p>
<p><a href="http://www.technology-ebay.de/the-teams/ebay-kleinanzeigen/blog/creating-a-cards-ui-on-android.html" target="_blank" rel="external">原文地址</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/译文/">译文</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/8/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/10/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 flyouting and shirley
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>